<!DOCTYPE html><html lang="en"> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><title>The Rust Language | Notes </title><meta name="title" content="The Rust Language | Richard's Notes"><meta name="description" content="Notes from learning Rust"><meta name="keywords" content="notes, Rust, Guide, Learning"><meta name="robots" content="index, follow"><meta name="language" content="English"><meta name="author" content="Richard C"><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://merichard123.github.io/"><meta property="twitter:title" content="The Rust Language | Richard's Notes"><meta property="twitter:description" content="Notes from learning Rust"><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="canonical" href="https://merichard123.github.io/"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css"><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Lato:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&display=swap" rel="stylesheet"><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"><link rel="manifest" href="/favicon/site.webmanifest"><link rel="stylesheet" href="/style/global.css"><link rel="stylesheet" href="/style/home.css"><style>footer[data-astro-cid-k2f5zb5c]{text-align:center;margin-top:2.5rem;padding:2rem;background-color:#f8f8f8;font-family:JetBrains Mono,Lato,sans-serif}p[data-astro-cid-k2f5zb5c]{font-size:1.1rem}
nav[data-astro-cid-lq7i5isa]{padding:1rem;background-color:#f5f5f5}a[data-astro-cid-lq7i5isa]{font-family:JetBrains Mono,Lato,sans-serif;text-decoration:none;color:#333}
</style></head> <header> <nav data-astro-cid-lq7i5isa> <a href="/" data-astro-cid-lq7i5isa>&lt/back</a> </nav>  </header> <div class="notes-container"> <h1 class="notes-title">The Rust Language</h1> <details><summary><span style="font-weight:bold; font-size: 1.4rem;">Contents</span></summary><ul>
<li><a href="#basic-io">Basic I/O</a>
<ul>
<li><a href="#dependencies">Dependencies</a></li>
</ul>
</li>
<li><a href="#data">Data</a>
<ul>
<li><a href="#shadowing">Shadowing</a></li>
<li><a href="#data-types">Data Types</a>
<ul>
<li><a href="#scalar-types">Scalar Types</a></li>
<li><a href="#compound-types">Compound Types</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#control-flow">Control Flow</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#ownership">Ownership</a>
<ul>
<li><a href="#the-stack-and-the-heap">The Stack and the Heap</a>
<ul>
<li><a href="#rules-of-ownership">Rules of Ownership</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#references-and-borrowing">References and Borrowing</a></li>
<li><a href="#the-slice-type">The Slice Type</a></li>
<li><a href="#structs">Structs</a>
<ul>
<li><a href="#methods">Methods</a>
<ul>
<li><a href="#c-and-c---operator">C++ and C -&gt; operator</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#enums">Enums </a></li>
<li><a href="#crates-and-modules">Crates and Modules</a></li>
<li><a href="#common-collections">Common Collections</a>
<ul>
<li><a href="#vectors">Vectors</a>
<ul>
<li><a href="#iteration:">Iteration:</a></li>
</ul>
</li>
<li><a href="#string">String</a></li>
</ul>
</li>
<li><a href="#hashmaps">HashMaps  </a></li>
<li><a href="#error-handling">Error Handling</a>
<ul>
<li><a href="#error-propagation">Error Propagation</a></li>
</ul>
</li>
<li><a href="#generic-types-traits-and-lifetimes">Generic Types, Traits and Lifetimes.</a>
<ul>
<li><a href="#traits">Traits</a></li>
<li><a href="#lifetimes">Lifetimes</a></li>
</ul>
</li>
<li><a href="#testing">Testing</a></li>
<li><a href="#functional-programming-in-rust">Functional Programming in Rust</a></li>
<li><a href="#iterators">Iterators</a></li>
<li><a href="#extra-patterns">Extra Patterns</a></li>
<li><a href="#destructuring">Destructuring</a></li>
</ul></details>
<ol>
<li>Start a New Project using: <code>cargo new [Project Name]</code></li>
<li>Build with: <code>cargo build</code></li>
<li>Build and Run: <code>cargo run</code></li>
<li>Check if it will compile without actually compiling: <code>cargo check</code></li>
<li>Build for release with optimisation: <code>cargo build --release</code></li>
</ol>
<h3 id="basic-io">Basic I/O</h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#6A737D">// add the library needed for processing inputs from the standard library</span></span>
<span class="line"><span style="color:#F97583">use</span><span style="color:#B392F0"> std</span><span style="color:#F97583">::</span><span style="color:#E1E4E8">io;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#6A737D">	// println! is used for output</span></span>
<span class="line"><span style="color:#B392F0">    println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Guess the number!&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">    println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Please input your guess.&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">	// define a mutable variable set to a new instance of a String</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#F97583"> mut</span><span style="color:#E1E4E8"> guess </span><span style="color:#F97583">=</span><span style="color:#B392F0"> String</span><span style="color:#F97583">::</span><span style="color:#B392F0">new</span><span style="color:#E1E4E8">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">	// read an input</span></span>
<span class="line"><span style="color:#B392F0">    io</span><span style="color:#F97583">::</span><span style="color:#B392F0">stdin</span><span style="color:#E1E4E8">()</span></span>
<span class="line"><span style="color:#F97583">        .</span><span style="color:#B392F0">read_line</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">&amp;mut</span><span style="color:#E1E4E8"> guess) </span><span style="color:#6A737D">// set the input to the guess varaible</span></span>
<span class="line"><span style="color:#6A737D">        // &amp;mut means we borrow the guess varaible and set it</span></span>
<span class="line"><span style="color:#F97583">        .</span><span style="color:#B392F0">expect</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Failed to read line&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">    println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;You guessed: {guess}&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p><code>println!</code> is a macro that prints to the screen.
This line creates a new variable named <code>apples</code> and binds it to the value 5. In Rust, variables are immutable by default, meaning once we give the variable a value, the value won’t change. Therefore we add <code>mut</code> to make it mutable.</p>
<p><code>::new()</code> indicates that the new function is an associated function of the String type. An <strong>Associated function</strong> is one that is implemented on a type.</p>
<blockquote>
<p>If we hadn’t imported the <code>io</code> library with <code>use std::io;</code> at the beginning of the program, we could still use the function by writing this function call as <code>std::io::stdin</code>. The <code>stdin</code> function returns an instance of <a href="https://doc.rust-lang.org/stable/std/io/struct.Stdin.html"><code>std::io::Stdin</code></a>, which is a type that represents a handle to the standard input for your terminal.</p>
</blockquote>
<p>The <code>&amp;</code> marks a reference to the guess varaiable.</p>
<p><code>read_line</code> puts whatever the user enters into the string we pass to it, but it also returns a <code>Result</code> value. <a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html"><code>Result</code></a> is an <a href="https://doc.rust-lang.org/stable/book/ch06-00-enums.html"><em>enumeration</em></a>, often called an <em>enum</em>, which is a type that can be in one of multiple possible states. We call each possible state a <em>variant</em>:</p>
<ul>
<li>0k</li>
<li>Err</li>
</ul>
<p>Rust strings are format strigns by default: <code>{}</code> set of curly brackets is a placeholder: little crab pincers that hold a value in place.</p>
<h4 id="dependencies">Dependencies</h4>
<p>We can add a dependency by adding it to the Cargo.toml file and running cargo build to install it.
We can use the installed Rng module for random number generation:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">use</span><span style="color:#B392F0"> rand</span><span style="color:#F97583">::</span><span style="color:#B392F0">Rng</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> secret_number </span><span style="color:#F97583">=</span><span style="color:#B392F0"> rand</span><span style="color:#F97583">::</span><span style="color:#B392F0">thread_rng</span><span style="color:#E1E4E8">()</span><span style="color:#F97583">.</span><span style="color:#B392F0">gen_range</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">1</span><span style="color:#F97583">..=</span><span style="color:#79B8FF">100</span><span style="color:#E1E4E8">);</span></span></code></pre>
<p>Rng is a trait defines a method that generates a random number. We call the <code>rand::thread_rng()</code> function to give use a generator we will use, then we call the <code>gen_range</code> method.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">use</span><span style="color:#B392F0"> std</span><span style="color:#F97583">::</span><span style="color:#E1E4E8">io;</span></span>
<span class="line"><span style="color:#F97583">use</span><span style="color:#B392F0"> std</span><span style="color:#F97583">::</span><span style="color:#B392F0">cmp</span><span style="color:#F97583">::</span><span style="color:#B392F0">Ordering</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">use</span><span style="color:#B392F0"> rand</span><span style="color:#F97583">::</span><span style="color:#B392F0">Rng</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#B392F0">    println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Guess the number!&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">    </span></span>
<span class="line"><span style="color:#F97583">	let</span><span style="color:#E1E4E8"> secret_number </span><span style="color:#F97583">=</span><span style="color:#B392F0"> rand</span><span style="color:#F97583">::</span><span style="color:#B392F0">thread_rng</span><span style="color:#E1E4E8">()</span><span style="color:#F97583">.</span><span style="color:#B392F0">gen_range</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">1</span><span style="color:#F97583">..=</span><span style="color:#79B8FF">100</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">	// loop lets us make an infinte loop</span></span>
<span class="line"><span style="color:#F97583">	loop</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">	    println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Please input your guess.&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">    </span></span>
<span class="line"><span style="color:#F97583">	    let</span><span style="color:#F97583"> mut</span><span style="color:#E1E4E8"> guess </span><span style="color:#F97583">=</span><span style="color:#B392F0"> String</span><span style="color:#F97583">::</span><span style="color:#B392F0">new</span><span style="color:#E1E4E8">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">	    io</span><span style="color:#F97583">::</span><span style="color:#B392F0">stdin</span><span style="color:#E1E4E8">()</span></span>
<span class="line"><span style="color:#F97583">	        .</span><span style="color:#B392F0">read_line</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">&amp;mut</span><span style="color:#E1E4E8"> guess) </span></span>
<span class="line"><span style="color:#F97583">	        .</span><span style="color:#B392F0">expect</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Failed to read line&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">	    // Rust uses a i32 type by default (a 32 bit number)</span></span>
<span class="line"><span style="color:#6A737D">		// secret number is i32 and guess is a string and it can&#39;t compare it</span></span>
<span class="line"><span style="color:#6A737D">		// we define a type on the var and prase will convert it to that type</span></span>
<span class="line"><span style="color:#F97583">		let</span><span style="color:#E1E4E8"> guess</span><span style="color:#F97583">:</span><span style="color:#B392F0"> u32</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> guess</span><span style="color:#F97583">.</span><span style="color:#B392F0">trim</span><span style="color:#E1E4E8">()</span><span style="color:#F97583">.</span><span style="color:#B392F0">parse</span><span style="color:#E1E4E8">()</span><span style="color:#F97583">.</span><span style="color:#B392F0">expect</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Please be a number&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">	</span></span>
<span class="line"><span style="color:#B392F0">	    println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;You guessed: {guess}&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">		</span></span>
<span class="line"><span style="color:#F97583">		match</span><span style="color:#E1E4E8"> guess</span><span style="color:#F97583">.</span><span style="color:#B392F0">cmp</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">&amp;</span><span style="color:#E1E4E8">secret_number) {</span></span>
<span class="line"><span style="color:#B392F0">			Ordering</span><span style="color:#F97583">::</span><span style="color:#B392F0">Less</span><span style="color:#F97583">    =&gt;</span><span style="color:#B392F0"> println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Too Small!&quot;</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#B392F0">			Ordering</span><span style="color:#F97583">::</span><span style="color:#B392F0">Greater</span><span style="color:#F97583"> =&gt;</span><span style="color:#B392F0"> println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Too big!&quot;</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#B392F0">			Ordering</span><span style="color:#F97583">::</span><span style="color:#B392F0">Equal</span><span style="color:#F97583">   =&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">				println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;You Win!&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">				break</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">			}</span></span>
<span class="line"><span style="color:#E1E4E8">		}</span></span>
<span class="line"><span style="color:#E1E4E8">	}</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Ordering is an Enum which has the 3 outcomes which result in the cmp compare functions. Rust has a couple number types:</p>
<ul>
<li>i32 = a 32 bit number</li>
<li>u32 = an unsigned 32 bit number</li>
<li>i64 = a 64 bit number</li>
<li>u64 = an unsigned 64 bit number</li>
</ul>
<p>We already have a guess variable but <strong>shadowing</strong> lets use define a new guess variable.</p>
<p>We should also handle errors:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">      let</span><span style="color:#E1E4E8"> guess</span><span style="color:#F97583">:</span><span style="color:#B392F0"> u32</span><span style="color:#F97583"> =</span><span style="color:#F97583"> match</span><span style="color:#E1E4E8"> guess</span><span style="color:#F97583">.</span><span style="color:#B392F0">trim</span><span style="color:#E1E4E8">()</span><span style="color:#F97583">.</span><span style="color:#B392F0">parse</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#B392F0">            Ok</span><span style="color:#E1E4E8">(num) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> num,</span></span>
<span class="line"><span style="color:#B392F0">            Err</span><span style="color:#E1E4E8">(_) </span><span style="color:#F97583">=&gt;</span><span style="color:#F97583"> continue</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">        };</span></span></code></pre>
<h2 id="data">Data</h2>
<p><strong>Variables</strong> in Rust are by default immutable. You can make them mutable by using the <code>mut</code> keyword:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">let</span><span style="color:#F97583"> mut</span><span style="color:#E1E4E8"> x </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 5</span><span style="color:#E1E4E8">;</span></span></code></pre>
<p>Constants are made like this and need a type:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> TIME</span><span style="color:#F97583"> :</span><span style="color:#B392F0"> u32</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> 60</span><span style="color:#F97583"> *</span><span style="color:#79B8FF"> 60</span><span style="color:#F97583"> *</span><span style="color:#79B8FF"> 3</span></span></code></pre>
<h3 id="shadowing">Shadowing</h3>
<p>We can declare another variable with the same name as a previous one. Rustaceans say that the first variable is <em>shadowed</em> by the second, which means that the second variable is what the compiler will see when you use the name of the variable.
The second variable overshadows the first.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> x </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 5</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> x </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> x </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">    {</span></span>
<span class="line"><span style="color:#F97583">        let</span><span style="color:#E1E4E8"> x </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> x </span><span style="color:#F97583">*</span><span style="color:#79B8FF"> 2</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#B392F0">        println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;The value of x in the inner scope is: {x}&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">    println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;The value of x is: {x}&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>If you don’t use let you are trying a modify a variable which isn’t mutable so it will throw an error. When we use let we are just defining a new variable and using the value of the previous one.</p>
<p>If a variable is mutable you can mutate its value but not its type.</p>
<h3 id="data-types">Data Types</h3>
<p>In rust a data type can either be a scalar or a compound.</p>
<h4 id="scalar-types">Scalar Types</h4>
<p>Integer:</p>








































<table><thead><tr><th>Length</th><th>Signed</th><th>Unsigned</th></tr></thead><tbody><tr><td>8-bit</td><td>i8</td><td>u8</td></tr><tr><td>16-bit</td><td>i16</td><td>u16</td></tr><tr><td>32-bit</td><td>i32</td><td>u32</td></tr><tr><td>64-bit</td><td>i64</td><td>u64</td></tr><tr><td>128-bit</td><td>i128</td><td>u128</td></tr><tr><td>arch</td><td>isize</td><td>usize</td></tr></tbody></table>
<p><code>isize</code> and <code>usize</code> are relative to the architecture the code is running on… if you are running on a 64 bit architecture then it will be 64 bits.</p>





























<table><thead><tr><th>Number literals</th><th>Example</th></tr></thead><tbody><tr><td>Decimal</td><td><code>98_222</code></td></tr><tr><td>Hex</td><td><code>0xff</code></td></tr><tr><td>Octal</td><td><code>0o77</code></td></tr><tr><td>Binary</td><td><code>0b1111_0000</code></td></tr><tr><td>Byte (<code>u8</code> only)</td><td><code>b&#39;A&#39;</code></td></tr></tbody></table>
<p>The primary situation in which you’d use <code>isize</code> or <code>usize</code> is when indexing some sort of collection. Rust uses the term <em>panicking</em> when a program exits with an error; often if you overflow your specified integer size.</p>
<p>In Rust <strong>floating point numbers</strong> are either <code>f32</code> or <code>f64</code> the default for a modern CPU is the 64-bit number.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> score</span><span style="color:#F97583">:</span><span style="color:#B392F0"> f64</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> 89.999999</span><span style="color:#E1E4E8">;</span></span></code></pre>
<p>We can use bool to specify a Boolean type:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> t </span><span style="color:#F97583">:</span><span style="color:#B392F0"> bool</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> false</span><span style="color:#E1E4E8">;</span></span></code></pre>
<p>Character Type:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> c </span><span style="color:#F97583">=</span><span style="color:#9ECBFF"> &#39;z&#39;</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> z</span><span style="color:#F97583">:</span><span style="color:#B392F0"> char</span><span style="color:#F97583"> =</span><span style="color:#9ECBFF"> &#39;ℤ&#39;</span><span style="color:#E1E4E8">; </span><span style="color:#6A737D">// with explicit type annotation</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> heart_eyed_cat </span><span style="color:#F97583">=</span><span style="color:#9ECBFF"> &#39;😻&#39;</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Rust Char uses <strong>4 bytes.</strong> This means it can represent a lot more than ascii it can do Accented letters, Chinese, Japanese, Korean Characters, Emojis, etc… It can also represent Unicode even though that is technically not a character.</p>
<h4 id="compound-types">Compound Types</h4>
<p>We can use <strong>tuples</strong> in Rust;</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> tup</span><span style="color:#F97583">:</span><span style="color:#E1E4E8"> (</span><span style="color:#B392F0">i32</span><span style="color:#E1E4E8">, </span><span style="color:#B392F0">f64</span><span style="color:#E1E4E8">, </span><span style="color:#B392F0">u8</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">500</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">6.4</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">	let</span><span style="color:#E1E4E8"> (x, y, z) </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> tup;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p><strong>Arrays</strong> in rust have a fixed length:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#6A737D">	// array a with 5 elements with a type of i32</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> a</span><span style="color:#F97583">:</span><span style="color:#E1E4E8"> [</span><span style="color:#B392F0">i32</span><span style="color:#E1E4E8">; </span><span style="color:#79B8FF">5</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">4</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">5</span><span style="color:#E1E4E8">];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">	// array b will look like this: [3,3,3,3,3]</span></span>
<span class="line"><span style="color:#F97583">	let</span><span style="color:#E1E4E8"> b</span><span style="color:#F97583">:</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8">; </span><span style="color:#79B8FF">5</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#B392F0">	println!</span><span style="color:#E1E4E8">(a[</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">]) </span><span style="color:#6A737D">// 1</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>a has a length of 5 and we can’t change that. A <strong>Arrays</strong> are useful when you want your data allocated on the stack rather than the heap.
A <strong>vector</strong> is a collection type which can grow in length.</p>
<h4 id="functions">Functions</h4>
<ul>
<li><strong>Statements</strong> are instructions that perform some action and do not return a value.</li>
<li><strong>Expressions</strong> evaluate to a resultant value.</li>
</ul>
<p>Rust code uses <em>snake case</em> as the conventional style for function and variable names, in which all letters are lowercase and underscores separate words.</p>
<p>Rust doesn’t care where you define a function as long as its in scope.
Rust is an expression based language, if we create a new scope in a function that is an expression:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> y </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">        let</span><span style="color:#E1E4E8"> x </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 3</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">        x </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span></span>
<span class="line"><span style="color:#E1E4E8">    };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">    println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;The value of y is: {y}&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Here y is bound to 4 because that score <strong>return</strong> 4 implictly. <strong>Note:</strong>  that the expression x+1 doesn’t end in a ; this is because if you add a semi colon it will become a statement and won’t be returned from the function:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> plus_one</span><span style="color:#E1E4E8">(x</span><span style="color:#F97583">:</span><span style="color:#B392F0"> i32</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">-&gt;</span><span style="color:#B392F0"> i32</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">	x </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<h4 id="control-flow">Control Flow</h4>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> number </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 3</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> number </span><span style="color:#F97583">&lt;</span><span style="color:#79B8FF"> 5</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">        println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;condition was true&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">else</span><span style="color:#F97583"> if</span><span style="color:#E1E4E8"> number </span><span style="color:#F97583">&gt;</span><span style="color:#79B8FF"> 20</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">	    println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Wowie Zowie&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">	else</span><span style="color:#E1E4E8">{</span></span>
<span class="line"><span style="color:#B392F0">        println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;condition was false&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Rust doesn’t auto convert everything into a boolean like most languages… hence you can’t do this:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> number </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 3</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> number {</span></span>
<span class="line"><span style="color:#B392F0">        println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;number was three&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Without casting to a bool first. Instead you can say <code>if number == 3</code></p>
<p>We ca use if in a let statement:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> condition </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> true</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#6A737D">// this will error if the types of 5 and 6 don&#39;t match</span></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> number </span><span style="color:#F97583">=</span><span style="color:#F97583"> if</span><span style="color:#E1E4E8"> condition { </span><span style="color:#79B8FF">5</span><span style="color:#E1E4E8"> } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> { </span><span style="color:#79B8FF">6</span><span style="color:#E1E4E8"> };</span></span></code></pre>
<p>Blocks of code evaluate to the last expression in them, and numbers by themselves are also expressions. In this case, the value of the whole <code>if</code> expression depends on which block of code executes.</p>
<p>We can return values from a loop using a break.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#F97583"> mut</span><span style="color:#E1E4E8"> counter </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> result </span><span style="color:#F97583">=</span><span style="color:#F97583"> loop</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">        counter </span><span style="color:#F97583">+=</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> counter </span><span style="color:#F97583">==</span><span style="color:#79B8FF"> 10</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">            break</span><span style="color:#E1E4E8"> counter </span><span style="color:#F97583">*</span><span style="color:#79B8FF"> 2</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#E1E4E8">    };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">    println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;The result is {result}&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>We can label loops if you have a lot of them:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#F97583"> mut</span><span style="color:#E1E4E8"> count </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">    &#39;</span><span style="color:#B392F0">counting_up</span><span style="color:#F97583">:</span><span style="color:#F97583"> loop</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">        println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;count = {count}&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">        let</span><span style="color:#F97583"> mut</span><span style="color:#E1E4E8"> remaining </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 10</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">        loop</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">            println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;remaining = {remaining}&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">            if</span><span style="color:#E1E4E8"> remaining </span><span style="color:#F97583">==</span><span style="color:#79B8FF"> 9</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">                break</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">            }</span></span>
<span class="line"><span style="color:#F97583">            if</span><span style="color:#E1E4E8"> count </span><span style="color:#F97583">==</span><span style="color:#79B8FF"> 2</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">                break</span><span style="color:#E1E4E8"> &#39;</span><span style="color:#B392F0">counting_up</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">            }</span></span>
<span class="line"><span style="color:#E1E4E8">            remaining </span><span style="color:#F97583">-=</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">        count </span><span style="color:#F97583">+=</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#B392F0">    println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;End count = {count}&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p><strong>A While</strong> loop is conditional:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#F97583"> mut</span><span style="color:#E1E4E8"> number </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 3</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    while</span><span style="color:#E1E4E8"> number </span><span style="color:#F97583">!=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">        println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;{number}!&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">        number </span><span style="color:#F97583">-=</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">    println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;LIFTOFF!!!&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p><strong>For</strong> loops!!</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> a </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">10</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">20</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">30</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">40</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">50</span><span style="color:#E1E4E8">];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> element </span><span style="color:#F97583">in</span><span style="color:#E1E4E8"> a {</span></span>
<span class="line"><span style="color:#B392F0">        println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;the value is: {element}&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Ranged loops, rev is only there to reverse the tuple.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> count_down</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> number </span><span style="color:#F97583">in</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">1</span><span style="color:#F97583">..</span><span style="color:#79B8FF">4</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">.</span><span style="color:#B392F0">rev</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#B392F0">        println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;{number}!&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#B392F0">    println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;LIFTOFF!!!&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<h2 id="ownership">Ownership</h2>
<p>Rust doesn’t have a garbage collector so we manage memory using ownership.</p>
<p><strong>Ownership</strong> = a set of rules that govern how a Rust program manages memory.
Most languages have a garbage collector which looks through and removes unused memory, others like C require you to explicitly allocate and free memory for data. Rust uses neither of these instead it uses a system of ownership.</p>
<h4 id="the-stack-and-the-heap">The Stack and the Heap</h4>
<p>Where in computer memory data is allocated may be useful for determining ownership,
A Stack in computer memory is a LIFO data structure. We can push data onto the stack or pop it off. All data on the stack has to have a fixed size, data with a size unknown at compile time has to go on the heap.
The heap is less organised, when add data on the heap ypu request a certain amount of memory. An allocator then finds an empty space that is big enough, and returns a pointer to the start of the data this is allocation. The pointer is a fixed size so you can store that on the stack.</p>
<ul>
<li>To get the actual data you have to follow the pointer.</li>
<li>Pushing to the stack is faster than the heap because there is no allocator involved and you don’t have to look for a free space.</li>
<li>Heap access is slower since you have to follow a pointer.</li>
</ul>
<p>When you call a function, the vaukes passed in and local function vars are pushed onto the stack, when the function is done the values are popped off the stack.</p>
<p>Keeping track of data on the heap, minimising duplicates and cleaning up are problems ownership solves.</p>
<h5 id="rules-of-ownership">Rules of Ownership</h5>
<ol>
<li>Each value has an owner.</li>
<li>There can only be one owner at a time.</li>
<li>When the owner goes out of scope the value is dropped.</li>
</ol>
<p>In Rust a variable is valid for as long as it’s in scope.</p>
<p>The <code>String</code> data type is one that doesn’t have a fixed size, so it is allocated on the heap and is mutable. You make one using a string literal and from:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">let</span><span style="color:#F97583"> mut</span><span style="color:#E1E4E8"> s </span><span style="color:#F97583">=</span><span style="color:#B392F0"> String</span><span style="color:#F97583">::</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;hello&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">s</span><span style="color:#F97583">.</span><span style="color:#B392F0">push_str</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;, world!&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#B392F0">println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;{}&quot;</span><span style="color:#E1E4E8">, s); </span><span style="color:#6A737D">// &quot;hello, world!&quot;</span></span></code></pre>
<p>For string literals we know its content at compile time so it is hardcoded in the executable. This makes string literals very fast. String allocates memory on the heap instead.
We need a way to return this memory to the allocator when it’s done.</p>
<p><code>String::from</code> allocates memory on the heap. In other languages like C we could need to free() this memory when we’re done, and in garbage collected languages this is automatic.
In Rust memory is autometically freed when we leave the scope.</p>
<p>When it goes out of scope rust calls a function called <code>drop</code> to free the memory.</p>
<blockquote>
<p>This pattern of deallocating resources at the end of an item’s lifetime is sometimes called <em>Resource Acquisition Is Initialization (RAII)</em>.  In  C++ this is done via malloc and free</p>
</blockquote>
<p>The stack holds the ptr, name, len and capacity of a String which is itself stored on the heap.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> s1 </span><span style="color:#F97583">=</span><span style="color:#B392F0"> String</span><span style="color:#F97583">::</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;hello&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> s2 </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> s1;</span></span></code></pre>
<p>If we do that we don’t copy the data in the heap we just add another pointer to that same address on the stack just under a different name.
This can be an issue because when they go out of scope drop will try to free the same bit of memory twice, so you get a double free error.</p>
<p>After the <code>let s2 = s1;</code> rust no longer considers the s1 variable as valid to avoid double freeing, since s1 is now out of scope and is dropped. This can be viewed as shallow copy with invalidation of the initial variable, we call this a <strong>move</strong>.
If you try to use the dropped value Rust will tell you it had been moved.</p>
<p>If however you do want to deep copy the heap data of String, not just the stack we use the <code>clone</code> method.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> s1 </span><span style="color:#F97583">=</span><span style="color:#B392F0"> String</span><span style="color:#F97583">::</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Hello&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> s2 </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> s1</span><span style="color:#F97583">.</span><span style="color:#B392F0">clone</span><span style="color:#E1E4E8">();</span></span></code></pre>
<p>For primitives however this doesn’t apply, variables aren’t dropped when you add a reference to them under a new name.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> x </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 5</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> y </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> x;</span></span></code></pre>
<p>x and y both exist because copying data in the stack is quick to do hence rust can just copy it. For these types there is no concept of moves, or deep copies.
We can annotate these using a <code>Copy</code> trait so we know it’s a copy, these variables on the stack aren’t moved but are copied. We can’t use <code>Copy</code> if the type implements <code>Drop</code>.</p>
<p><strong>Ownership and Functions</strong>
When you pass a value to a function the variable is moved, the function takes ownership of it automatically and drops it when it’s done.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> s </span><span style="color:#F97583">=</span><span style="color:#B392F0"> String</span><span style="color:#F97583">::</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;hello&quot;</span><span style="color:#E1E4E8">);  </span><span style="color:#6A737D">// s comes into scope</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">    takes_ownership</span><span style="color:#E1E4E8">(s);             </span><span style="color:#6A737D">// s&#39;s value moves into the function...</span></span>
<span class="line"><span style="color:#6A737D">                                    // ... and so is no longer valid here</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> x </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 5</span><span style="color:#E1E4E8">;                      </span><span style="color:#6A737D">// x comes into scope</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">    makes_copy</span><span style="color:#E1E4E8">(x);                  </span><span style="color:#6A737D">// x would move into the function,</span></span>
<span class="line"><span style="color:#6A737D">                                    // but i32 is Copy, so it&#39;s okay to still</span></span>
<span class="line"><span style="color:#6A737D">                                    // use x afterward</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">} </span><span style="color:#6A737D">// Here, x goes out of scope, then s. But because s&#39;s value was moved, nothing</span></span>
<span class="line"><span style="color:#6A737D">  // special happens.</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> takes_ownership</span><span style="color:#E1E4E8">(some_string</span><span style="color:#F97583">:</span><span style="color:#B392F0"> String</span><span style="color:#E1E4E8">) { </span><span style="color:#6A737D">// some_string comes into scope</span></span>
<span class="line"><span style="color:#B392F0">    println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;{}&quot;</span><span style="color:#E1E4E8">, some_string);</span></span>
<span class="line"><span style="color:#E1E4E8">} </span><span style="color:#6A737D">// Here, some_string goes out of scope and `drop` is called. The backing</span></span>
<span class="line"><span style="color:#6A737D">  // memory is freed.</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> makes_copy</span><span style="color:#E1E4E8">(some_integer</span><span style="color:#F97583">:</span><span style="color:#B392F0"> i32</span><span style="color:#E1E4E8">) { </span><span style="color:#6A737D">// some_integer comes into scope</span></span>
<span class="line"><span style="color:#B392F0">    println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;{}&quot;</span><span style="color:#E1E4E8">, some_integer);</span></span>
<span class="line"><span style="color:#E1E4E8">} </span><span style="color:#6A737D">// Here, some_integer goes out of scope. Nothing special happens.</span></span></code></pre>
<p>When you return a value from a function its ownership is transferred to where ever your return value is bound. So if a <code>name()</code> returned a string and we bind it <code>let name = name()</code> then the return value is now owned by name.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> calc_len</span><span style="color:#E1E4E8">(s</span><span style="color:#F97583">:</span><span style="color:#B392F0"> String</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">-&gt;</span><span style="color:#E1E4E8"> (</span><span style="color:#B392F0">String</span><span style="color:#E1E4E8">, </span><span style="color:#B392F0">usize</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">	let</span><span style="color:#E1E4E8"> length </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> s</span><span style="color:#F97583">.</span><span style="color:#B392F0">len</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">	(s, length) </span><span style="color:#6A737D">// multiple vaues returned</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<h2 id="references-and-borrowing">References and Borrowing</h2>
<p>Instead of transferring ownership we can allow a function to borrow a value for use, we do this by providing a reference or pointer which points to the addess we can follow to find the data.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> s1 </span><span style="color:#F97583">=</span><span style="color:#B392F0"> String</span><span style="color:#F97583">::</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;hello&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> len </span><span style="color:#F97583">=</span><span style="color:#B392F0"> calculate_length</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">&amp;</span><span style="color:#E1E4E8">s1);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">    println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;The length of &#39;{}&#39; is {}.&quot;</span><span style="color:#E1E4E8">, s1, len);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> calculate_length</span><span style="color:#E1E4E8">(s</span><span style="color:#F97583">:</span><span style="color:#F97583"> &amp;</span><span style="color:#B392F0">String</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">-&gt;</span><span style="color:#B392F0"> usize</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">    s</span><span style="color:#F97583">.</span><span style="color:#B392F0">len</span><span style="color:#E1E4E8">()</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>The <code>&amp;</code> denotes an address (pointer/ reference) allowing us to reference a value rather than taking ownership of it.
We can use * to dereference a pointer. References are dropped when out of scope.
When we pass a reference we don’t need to return it in order to give back ownership since we never had it in the first place.</p>
<p>This idea of creating a reference is called <strong>borrowing</strong>. We can’t modify a borrowed value but we can use it.</p>
<p><strong>Mutable References</strong></p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">	let</span><span style="color:#F97583"> mut</span><span style="color:#E1E4E8"> s </span><span style="color:#F97583">=</span><span style="color:#B392F0"> String</span><span style="color:#F97583">::</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Hello&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#B392F0">	change</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">&amp;mut</span><span style="color:#E1E4E8"> s);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> change</span><span style="color:#E1E4E8">(some_string</span><span style="color:#F97583">:</span><span style="color:#F97583"> &amp;mut</span><span style="color:#B392F0"> String</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">	some_string</span><span style="color:#F97583">:</span><span style="color:#B392F0">push_str</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;, World&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>If we want to modify a reference we have to pass a mutable reference. You can only ever have 1 mutable reference to a value at a time (per scope).
We <em>also</em> cannot have a mutable reference while we have an immutable one to the same value.</p>
<p>Rust doesn’t allow danging pointers it will say: <code>text this function&#39;s return type contains a borrowed value, but there is no value for it to be borrowed from</code>.
Rust will clean up dangling pointers.</p>
<h2 id="the-slice-type">The Slice Type</h2>
<p>Slices let you referece contiguous sequences of elements in a collection rather than a whole collection. A slice is a reference so it has no ownership.</p>
<p>If we are writing a function to find some data or an index, you data will be out of sync with your string because the data is separate from the string itself. So when the string changes the index will and you get issues.
To fix this we can use string slices. A slice is a reference to part of a string:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> s </span><span style="color:#F97583">=</span><span style="color:#B392F0"> String</span><span style="color:#F97583">::</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;hello world&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> hello </span><span style="color:#F97583">=</span><span style="color:#F97583"> &amp;</span><span style="color:#E1E4E8">s[</span><span style="color:#79B8FF">0</span><span style="color:#F97583">..</span><span style="color:#79B8FF">5</span><span style="color:#E1E4E8">];</span></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> world </span><span style="color:#F97583">=</span><span style="color:#F97583"> &amp;</span><span style="color:#E1E4E8">s[</span><span style="color:#79B8FF">6</span><span style="color:#F97583">..</span><span style="color:#79B8FF">11</span><span style="color:#E1E4E8">];</span></span></code></pre>
<p>Rather than being a reference to the whole string, hello is a reference to part of the String; specified by the <code>[startIndex..endIndex]</code>. Internally this stores the length of the string and the string position. World is a slice that contains a pointer to the byte at index 6, with a length of 5.
If the first index is 0, or last == length you can drop the number:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> hello </span><span style="color:#F97583">=</span><span style="color:#F97583"> &amp;</span><span style="color:#E1E4E8">s[</span><span style="color:#F97583">..</span><span style="color:#79B8FF">5</span><span style="color:#E1E4E8">];</span></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> slice </span><span style="color:#F97583">=</span><span style="color:#F97583"> &amp;</span><span style="color:#E1E4E8">s[</span><span style="color:#79B8FF">3</span><span style="color:#F97583">..</span><span style="color:#E1E4E8">];</span></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> wholeString </span><span style="color:#F97583">=</span><span style="color:#F97583"> &amp;</span><span style="color:#E1E4E8">s[</span><span style="color:#F97583">..</span><span style="color:#E1E4E8">]</span></span></code></pre>
<p>We can now write fist word like this:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> first_word</span><span style="color:#E1E4E8">(s</span><span style="color:#F97583">:</span><span style="color:#F97583"> &amp;</span><span style="color:#B392F0">String</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">-&gt;</span><span style="color:#F97583"> &amp;</span><span style="color:#B392F0">str</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> bytes </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> s</span><span style="color:#F97583">.</span><span style="color:#B392F0">as_bytes</span><span style="color:#E1E4E8">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> (i, </span><span style="color:#F97583">&amp;</span><span style="color:#E1E4E8">item) </span><span style="color:#F97583">in</span><span style="color:#E1E4E8"> bytes</span><span style="color:#F97583">.</span><span style="color:#B392F0">iter</span><span style="color:#E1E4E8">()</span><span style="color:#F97583">.</span><span style="color:#B392F0">enumerate</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> item </span><span style="color:#F97583">==</span><span style="color:#9ECBFF"> b&#39; &#39;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">            return</span><span style="color:#F97583"> &amp;</span><span style="color:#E1E4E8">s[</span><span style="color:#79B8FF">0</span><span style="color:#F97583">..</span><span style="color:#E1E4E8">i];</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#F97583"> &amp;</span><span style="color:#E1E4E8">s[</span><span style="color:#F97583">..</span><span style="color:#E1E4E8">];</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Now if you clear the string the compiler will error because the string change: <code>console cannot borrow &#39;s&#39; as mutable because it is also borrowed as immutable</code>.
We can also use a slice in the parameter of the function, this will let us pass in <code>&amp;str</code> or a <code>&amp;String</code> in to the function.</p>
<p>Slices also work in arrays, if we slice an array of numbers it will have a type of <code>&amp;[i32]</code>.</p>
<h2 id="structs">Structs</h2>
<p>Strucs are similar to tuples but they have named related values.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">struct</span><span style="color:#B392F0"> User</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">	active</span><span style="color:#F97583">:</span><span style="color:#B392F0"> bool</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">	username</span><span style="color:#F97583">:</span><span style="color:#B392F0"> String</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">	email</span><span style="color:#F97583">:</span><span style="color:#B392F0"> String</span><span style="color:#E1E4E8">, </span></span>
<span class="line"><span style="color:#E1E4E8">	sign_in_count</span><span style="color:#F97583">:</span><span style="color:#B392F0"> u64</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>We can define data on the struct:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> user1 </span><span style="color:#F97583">=</span><span style="color:#B392F0"> User</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">        active</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> true</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">        username</span><span style="color:#F97583">:</span><span style="color:#B392F0"> String</span><span style="color:#F97583">::</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;someusername123&quot;</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#E1E4E8">        email</span><span style="color:#F97583">:</span><span style="color:#B392F0"> String</span><span style="color:#F97583">::</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;someone@example.com&quot;</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#E1E4E8">        sign_in_count</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">    };</span></span>
<span class="line"><span style="color:#E1E4E8">	user1</span><span style="color:#F97583">.</span><span style="color:#E1E4E8">email </span><span style="color:#F97583">=</span><span style="color:#B392F0"> String</span><span style="color:#F97583">::</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;someoneelse@example.com&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Struct instances have to be mutable; Rust doesn’t let you mark only certain fields as mutable. We normally construct a new instance using field init shorthand:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> build_user</span><span style="color:#E1E4E8">(email</span><span style="color:#F97583">:</span><span style="color:#B392F0"> String</span><span style="color:#E1E4E8">, username</span><span style="color:#F97583">:</span><span style="color:#B392F0"> String</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">-&gt;</span><span style="color:#B392F0"> User</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">	User</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">		active</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> true</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">		username,</span></span>
<span class="line"><span style="color:#E1E4E8">		email,</span></span>
<span class="line"><span style="color:#E1E4E8">		sign_in_count</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">	}</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> getFractionSignin</span><span style="color:#E1E4E8">(user</span><span style="color:#F97583">:</span><span style="color:#F97583"> &amp;</span><span style="color:#B392F0">User</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">-&gt;</span><span style="color:#B392F0"> f32</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">	let</span><span style="color:#E1E4E8"> total </span><span style="color:#F97583">=</span><span style="color:#B392F0"> query_total_users</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">	user</span><span style="color:#F97583">.</span><span style="color:#E1E4E8">sign_in_count </span><span style="color:#F97583">/</span><span style="color:#E1E4E8"> total</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">	let</span><span style="color:#E1E4E8"> user1</span><span style="color:#F97583">:</span><span style="color:#B392F0"> User</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> build_user</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;email@company.com&quot;</span><span style="color:#E1E4E8">, </span><span style="color:#9ECBFF">&quot;steven&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#6A737D">	// borrow user1</span></span>
<span class="line"><span style="color:#F97583">	let</span><span style="color:#E1E4E8"> signinFraction</span><span style="color:#F97583">:</span><span style="color:#B392F0"> f32</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> getFractionSignin</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">&amp;</span><span style="color:#E1E4E8">user1);</span></span>
<span class="line"><span style="color:#B392F0">	println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;{signinFraction * 100*}%&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>We can use existing Structs to make new structs:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">(){</span></span>
<span class="line"><span style="color:#F97583">	let</span><span style="color:#E1E4E8"> user2 </span><span style="color:#F97583">=</span><span style="color:#B392F0"> User</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">		email</span><span style="color:#F97583">:</span><span style="color:#B392F0"> String</span><span style="color:#F97583">::</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;another@example.com&quot;</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#F97583">		..</span><span style="color:#E1E4E8">user1</span></span>
<span class="line"><span style="color:#E1E4E8">	}</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Structs don’t have to use named fields:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">struct</span><span style="color:#B392F0"> Colour</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">i32</span><span style="color:#E1E4E8">, </span><span style="color:#B392F0">i32</span><span style="color:#E1E4E8">, </span><span style="color:#B392F0">i32</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">struct</span><span style="color:#B392F0"> Point</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">i32</span><span style="color:#E1E4E8">, </span><span style="color:#B392F0">i32</span><span style="color:#E1E4E8">, </span><span style="color:#B392F0">i32</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">	let</span><span style="color:#E1E4E8"> black </span><span style="color:#F97583">=</span><span style="color:#B392F0"> Colour</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">,</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">,</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">	let</span><span style="color:#E1E4E8"> origin </span><span style="color:#F97583">=</span><span style="color:#B392F0"> Point</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">,</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">,</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>We can also define unit-type structs with no data:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">struct</span><span style="color:#B392F0"> AlwaysEqual</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> subject </span><span style="color:#F97583">=</span><span style="color:#B392F0"> AlwaysEqual</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>If we want to be able to print the struct we need to derive the println macro:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#E1E4E8">#[derive(</span><span style="color:#B392F0">Debug</span><span style="color:#E1E4E8">)]</span></span>
<span class="line"><span style="color:#E1E4E8">struc </span><span style="color:#B392F0">Rectangle</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">	width</span><span style="color:#F97583">:</span><span style="color:#B392F0"> u32</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">	height</span><span style="color:#F97583">:</span><span style="color:#B392F0"> u32</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> rect1 </span><span style="color:#F97583">=</span><span style="color:#B392F0"> Rectangle</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">        width</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> 30</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">        height</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> 50</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">    };</span></span>
<span class="line"><span style="color:#6A737D">	// using {:#?} instead will make the output nicer. </span></span>
<span class="line"><span style="color:#B392F0">    println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;rect1 is {:?}&quot;</span><span style="color:#E1E4E8">, rect1);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre>
<h3 id="methods">Methods</h3>
<p>Methods are functions bound to a struct, enum or trait. It requires an instance to self.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#E1E4E8">#[derive(</span><span style="color:#B392F0">Debug</span><span style="color:#E1E4E8">)]</span></span>
<span class="line"><span style="color:#F97583">struct</span><span style="color:#B392F0"> Rectangle</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">    width</span><span style="color:#F97583">:</span><span style="color:#B392F0"> u32</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">    height</span><span style="color:#F97583">:</span><span style="color:#B392F0"> u32</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">// implementation for Rectangle</span></span>
<span class="line"><span style="color:#F97583">impl</span><span style="color:#B392F0"> Rectangle</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">	// &amp;self is a borrow of the Self instance of Rectangle</span></span>
<span class="line"><span style="color:#F97583">    fn</span><span style="color:#B392F0"> area</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">&amp;</span><span style="color:#79B8FF">self</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">-&gt;</span><span style="color:#B392F0"> u32</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#79B8FF">        self</span><span style="color:#F97583">.</span><span style="color:#E1E4E8">width </span><span style="color:#F97583">*</span><span style="color:#79B8FF"> self</span><span style="color:#F97583">.</span><span style="color:#E1E4E8">height</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#F97583">    fn</span><span style="color:#B392F0"> can_hold</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">&amp;</span><span style="color:#79B8FF">self</span><span style="color:#E1E4E8">, other</span><span style="color:#F97583">:</span><span style="color:#F97583"> &amp;</span><span style="color:#B392F0">Rectangle</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">-&gt;</span><span style="color:#B392F0"> bool</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#79B8FF">        self</span><span style="color:#F97583">.</span><span style="color:#E1E4E8">width </span><span style="color:#F97583">&gt;</span><span style="color:#E1E4E8"> other</span><span style="color:#F97583">.</span><span style="color:#E1E4E8">width </span><span style="color:#F97583">&amp;&amp;</span><span style="color:#79B8FF"> self</span><span style="color:#F97583">.</span><span style="color:#E1E4E8">height </span><span style="color:#F97583">&gt;</span><span style="color:#E1E4E8"> other</span><span style="color:#F97583">.</span><span style="color:#E1E4E8">height</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> rect1 </span><span style="color:#F97583">=</span><span style="color:#B392F0"> Rectangle</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">        width</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> 30</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">        height</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> 50</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">    };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">    println!</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#9ECBFF">        &quot;The area of the rectangle is {} square pixels.&quot;</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">        rect1</span><span style="color:#F97583">.</span><span style="color:#B392F0">area</span><span style="color:#E1E4E8">()</span></span>
<span class="line"><span style="color:#E1E4E8">    );</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>You can if you really wanted to call an implemented function the same name as an attribute.</p>
<h4 id="c-and-c---operator">C++ and C -&gt; operator</h4>
<p>In C you can call methods in two ways:</p>
<ul>
<li>Directly from an Object: <code>Object.method()</code></li>
<li>From a pointer to an Object dereferencing it first: <code>Object-&gt;method()</code>
<ul>
<li>Used of Object is a pointer similar to: <code>(*Object).method()</code></li>
</ul>
</li>
</ul>
<p>Rust has <em>automatic referencing and dereferencing</em> for method calls; it will automatically add <code>&amp;</code>, <code>&amp;mut</code> or <code>*</code> so that the object matches the signture of the method. E.g. the following are the same:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#E1E4E8">p1</span><span style="color:#F97583">.</span><span style="color:#B392F0">distance</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">&amp;</span><span style="color:#E1E4E8">p2);</span></span>
<span class="line"><span style="color:#E1E4E8">(</span><span style="color:#F97583">&amp;</span><span style="color:#E1E4E8">p1)</span><span style="color:#F97583">.</span><span style="color:#B392F0">distance</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">&amp;</span><span style="color:#E1E4E8">p2);</span></span></code></pre>
<p>Given the object p1 rust implies whether we need to read (&amp;self), mutate (&amp;mut self) or consuming a value (self).
Functions defined within <code>impl</code> are associated functions because they don’t have self as a parameter and are associated with the type after named after impl.</p>
<p>Let’s say we define a constructor:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">impl</span><span style="color:#B392F0"> Rectangle</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    fn</span><span style="color:#B392F0"> New</span><span style="color:#E1E4E8">(size</span><span style="color:#F97583">:</span><span style="color:#B392F0"> u32</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">-&gt;</span><span style="color:#79B8FF"> Self</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#79B8FF">        Self</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">            width</span><span style="color:#F97583">:</span><span style="color:#E1E4E8"> size,</span></span>
<span class="line"><span style="color:#E1E4E8">            height</span><span style="color:#F97583">:</span><span style="color:#E1E4E8"> size,</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#B392F0">	Rectangle</span><span style="color:#F97583">::</span><span style="color:#B392F0">New</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">7</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>We call associated functions using ’::’ along with the struct name. You couls also split the implementation up and have 1 <code>impl</code> block per method.</p>
<h2 id="enums">Enums</h2>
<p>Define a type by enumerating all possible variants. For example we can define the two possible states of an IP address:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">enum</span><span style="color:#B392F0"> IpAddrKind</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">    V4</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#B392F0">    V6</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Create instances:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> four </span><span style="color:#F97583">=</span><span style="color:#B392F0"> IpAddrKind</span><span style="color:#F97583">::</span><span style="color:#B392F0">V4</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> six </span><span style="color:#F97583">=</span><span style="color:#B392F0"> IpAddrKind</span><span style="color:#F97583">::</span><span style="color:#B392F0">V6</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> route</span><span style="color:#E1E4E8">(ip_kind</span><span style="color:#F97583">:</span><span style="color:#B392F0"> IpAddrKind</span><span style="color:#E1E4E8">) {}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">route</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">IpAddrKind</span><span style="color:#F97583">::</span><span style="color:#B392F0">V4</span><span style="color:#E1E4E8">);</span></span></code></pre>
<p>We could represent an Ip address using a struct with an IpKind parameter but using an enum is more concise since we can add data to them:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">enum</span><span style="color:#B392F0"> IpAddr</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">	V4</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">String</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#B392F0">	V6</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">String</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> home </span><span style="color:#F97583">=</span><span style="color:#B392F0"> IpAddr</span><span style="color:#F97583">::</span><span style="color:#B392F0">V4</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">String</span><span style="color:#F97583">::</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;127.0.0.1&quot;</span><span style="color:#E1E4E8">));</span></span></code></pre>
<p>Enums can hold a range of types:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">enum</span><span style="color:#B392F0"> Message</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">    Quit</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#B392F0">    Move</span><span style="color:#E1E4E8"> { x</span><span style="color:#F97583">:</span><span style="color:#B392F0"> i32</span><span style="color:#E1E4E8">, y</span><span style="color:#F97583">:</span><span style="color:#B392F0"> i32</span><span style="color:#E1E4E8"> },</span></span>
<span class="line"><span style="color:#B392F0">    Write</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">String</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#B392F0">    ChangeColor</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">i32</span><span style="color:#E1E4E8">, </span><span style="color:#B392F0">i32</span><span style="color:#E1E4E8">, </span><span style="color:#B392F0">i32</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>If we did this using a struct we would need 4 separate structs.</p>
<p><strong>Optional Values</strong>
In most languages this is done via an implementation of <code>null</code> rust doesn’t have a null implementation because it has learned from other languages and saw that null normally causes bugs. Instead we use an Option enum which id defined in std like so:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">enum</span><span style="color:#B392F0"> Option</span><span style="color:#E1E4E8">&lt;</span><span style="color:#B392F0">T</span><span style="color:#E1E4E8">&gt; {</span></span>
<span class="line"><span style="color:#B392F0">	None</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#B392F0">	Some</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">T</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>We can use the <code>Option&lt;T&gt;</code> type to show an absence of values:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> some_number </span><span style="color:#F97583">=</span><span style="color:#B392F0"> Some</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">5</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> no_number</span><span style="color:#F97583">:</span><span style="color:#B392F0"> Option</span><span style="color:#E1E4E8">&lt;</span><span style="color:#B392F0">i32</span><span style="color:#E1E4E8">&gt; </span><span style="color:#F97583">=</span><span style="color:#B392F0"> None</span><span style="color:#E1E4E8">;</span></span></code></pre>
<p>The type of some_number is <code>Option&lt;char&gt;</code> this is inferred because we specified a value in <code>Some</code>. Since no_number has no value rust can’t infer it, we have to give it a type.</p>
<p>We cannot add <code>i8</code> and <code>Option&lt;i8&gt;</code> because there is a chance there is no value. So we have to convert <code>Option&lt;T&gt;</code> to type <code>T</code> first.  If we want to get the value in Some we can call the <code>.unwrap()</code> method.</p>
<p>Enums are very handy in defining match conditions:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">enum</span><span style="color:#B392F0"> Coin</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">    Penny</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#B392F0">    Nickel</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#B392F0">    Dime</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#B392F0">    Quarter</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> value_in_cents</span><span style="color:#E1E4E8">(coin</span><span style="color:#F97583">:</span><span style="color:#B392F0"> Coin</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">-&gt;</span><span style="color:#B392F0"> u8</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    match</span><span style="color:#E1E4E8"> coin {</span></span>
<span class="line"><span style="color:#B392F0">        Coin</span><span style="color:#F97583">::</span><span style="color:#B392F0">Penny</span><span style="color:#F97583"> =&gt;</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#B392F0">        Coin</span><span style="color:#F97583">::</span><span style="color:#B392F0">Nickel</span><span style="color:#F97583"> =&gt;</span><span style="color:#79B8FF"> 5</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#B392F0">        Coin</span><span style="color:#F97583">::</span><span style="color:#B392F0">Dime</span><span style="color:#F97583"> =&gt;</span><span style="color:#79B8FF"> 10</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#B392F0">        Coin</span><span style="color:#F97583">::</span><span style="color:#B392F0">Quarter</span><span style="color:#F97583"> =&gt;</span><span style="color:#79B8FF"> 25</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>also very useful for matching the Option type:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">   fn</span><span style="color:#B392F0"> plus_one</span><span style="color:#E1E4E8">(x</span><span style="color:#F97583">:</span><span style="color:#B392F0"> Option</span><span style="color:#E1E4E8">&lt;</span><span style="color:#B392F0">i32</span><span style="color:#E1E4E8">&gt;) </span><span style="color:#F97583">-&gt;</span><span style="color:#B392F0"> Option</span><span style="color:#E1E4E8">&lt;</span><span style="color:#B392F0">i32</span><span style="color:#E1E4E8">&gt; {</span></span>
<span class="line"><span style="color:#F97583">        match</span><span style="color:#E1E4E8"> x {</span></span>
<span class="line"><span style="color:#B392F0">            None</span><span style="color:#F97583"> =&gt;</span><span style="color:#B392F0"> None</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#B392F0">            Some</span><span style="color:#E1E4E8">(i) </span><span style="color:#F97583">=&gt;</span><span style="color:#B392F0"> Some</span><span style="color:#E1E4E8">(i </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> five </span><span style="color:#F97583">=</span><span style="color:#B392F0"> Some</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">5</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> six </span><span style="color:#F97583">=</span><span style="color:#B392F0"> plus_one</span><span style="color:#E1E4E8">(five);</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> none </span><span style="color:#F97583">=</span><span style="color:#B392F0"> plus_one</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">None</span><span style="color:#E1E4E8">);</span></span></code></pre>
<p>Matches are exhaustive and thus must cover all possibilities. We can use <code>_</code> as a match pattern to catch everything else we haven’t specified.</p>
<p>Often if we only want to match one pattern and ignore the rest we would do this:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> config_max </span><span style="color:#F97583">=</span><span style="color:#B392F0"> Some</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">3</span><span style="color:#B392F0">u8</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">    match</span><span style="color:#E1E4E8"> config_max {</span></span>
<span class="line"><span style="color:#B392F0">        Some</span><span style="color:#E1E4E8">(max) </span><span style="color:#F97583">=&gt;</span><span style="color:#B392F0"> println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;The maximum is configured to be {}&quot;</span><span style="color:#E1E4E8">, max),</span></span>
<span class="line"><span style="color:#E1E4E8">        _ </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> (),</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span></code></pre>
<p>but we can make this cleaner using an <code>if let</code> binding:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> config_max </span><span style="color:#F97583">=</span><span style="color:#B392F0"> Some</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">3</span><span style="color:#B392F0">u8</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#F97583"> let</span><span style="color:#B392F0"> Some</span><span style="color:#E1E4E8">(max) </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> config_max {</span></span>
<span class="line"><span style="color:#B392F0">        println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;The maximum is configured to be {}&quot;</span><span style="color:#E1E4E8">, max);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span></code></pre>
<p>if let takes a pattern and an expression separated by an equal sign.</p>
<h2 id="crates-and-modules">Crates and Modules</h2>
<ul>
<li><strong>Packages:</strong> A Cargo feature that lets you build, test, and share crates</li>
<li><strong>Crates:</strong> A tree of modules that produces a library or executable</li>
<li><strong>Modules</strong> and <strong>use:</strong> Let you control the organization, scope, and privacy of paths</li>
<li><strong>Paths:</strong> A way of naming an item, such as a struct, function, or module</li>
</ul>
<p>A Crate is a single rust file. Crates contain modules. A crate can either be a library or binary crate.
<strong>A Binary</strong> crate is one you compile to an executable, each one must have a main function.
<strong>Library</strong> creates don’t have main functions and don’t compile to an executable. They define functionality which will be shared between projects. Crate = Library.</p>
<ol>
<li>Compiler starts at the root <code>src/lib.rs</code> for a library crate or <code>src/main.rs</code> for a binary crate.</li>
<li>Declare a module using the <code>mod</code> keyword. Let’s say you make a file called <code>garden.rs</code> in the main file you can declare it as a module <code>mod garden;</code></li>
<li>If you declare a module a file that isn’t the root is it a submodule. If we declare a <code>mod vegetables</code> in the <code>garden.rs</code> file then vegetables will be a submodule.</li>
<li>Use functions from a module like this: <code>crate::garden::vegetables::Asparagus</code></li>
<li>Use <code>pub mod</code> to declare a public module because by default all modules are private.</li>
<li>The <code>use</code> keyword create a shortcut to long paths like <code>crate::garden::vegetables::Asparagus</code> we can instead put <code>use crate::graden::vegetables::Asparagus</code> at the top of the file and just use the Asparagus function.
<a href="https://doc.rust-lang.org/stable/book/ch07-02-defining-modules-to-control-scope-and-privacy.html">https://doc.rust-lang.org/stable/book/ch07-02-defining-modules-to-control-scope-and-privacy.html</a></li>
</ol>
<h2 id="common-collections">Common Collections</h2>
<h3 id="vectors">Vectors</h3>
<p>The <code>Vec&lt;T&gt;</code> type allows you to store more than one value in a single data structure that puts all the values next to each other in memory. They only stores values of one type.
We can make an empty vector:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> v</span><span style="color:#F97583">:</span><span style="color:#B392F0"> Vec</span><span style="color:#E1E4E8">&lt;</span><span style="color:#B392F0">i32</span><span style="color:#E1E4E8">&gt; </span><span style="color:#F97583">=</span><span style="color:#B392F0"> Vec</span><span style="color:#F97583">::</span><span style="color:#B392F0">new</span><span style="color:#E1E4E8">();</span></span></code></pre>
<p>However we can also use a macro for making a vector of values:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#6A737D">// rust infers the type here</span></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#F97583"> mut</span><span style="color:#E1E4E8"> v </span><span style="color:#F97583">=</span><span style="color:#B392F0"> vec!</span><span style="color:#E1E4E8">[</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">,</span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">,</span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8">];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">// adding values:</span></span>
<span class="line"><span style="color:#E1E4E8">v</span><span style="color:#F97583">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">4</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">v</span><span style="color:#F97583">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">5</span><span style="color:#E1E4E8">);</span></span></code></pre>
<p><strong>Accessing Data</strong></p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> v </span><span style="color:#F97583">=</span><span style="color:#B392F0"> vec!</span><span style="color:#E1E4E8">[</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">,</span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">,</span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8">,</span><span style="color:#79B8FF">4</span><span style="color:#E1E4E8">,</span><span style="color:#79B8FF">5</span><span style="color:#E1E4E8">];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> third</span><span style="color:#F97583">:</span><span style="color:#F97583"> &amp;</span><span style="color:#B392F0">i32</span><span style="color:#F97583"> =</span><span style="color:#F97583"> &amp;</span><span style="color:#E1E4E8">v[</span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">// or using get</span></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> third</span><span style="color:#F97583">:</span><span style="color:#B392F0"> Option</span><span style="color:#E1E4E8">&lt;</span><span style="color:#F97583">&amp;</span><span style="color:#B392F0">i32</span><span style="color:#E1E4E8">&gt; </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> v</span><span style="color:#F97583">.</span><span style="color:#B392F0">get</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">match</span><span style="color:#E1E4E8"> third {</span></span>
<span class="line"><span style="color:#B392F0">	Some</span><span style="color:#E1E4E8">(third) </span><span style="color:#F97583">=&gt;</span><span style="color:#B392F0"> println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Third value is: {third}.&quot;</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#B392F0">	None</span><span style="color:#F97583"> =&gt;</span><span style="color:#B392F0"> println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;there is no 3rd element.&quot;</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Here we are using &amp; to get a reference to the element.
Using [] for access will cause the program to panic when the index is out of range. If you use get it will return None if it is out of range and will not panic. If index is uncertain use get.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">let</span><span style="color:#F97583"> mut</span><span style="color:#E1E4E8"> v </span><span style="color:#F97583">=</span><span style="color:#B392F0"> vec!</span><span style="color:#E1E4E8">[</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">4</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">5</span><span style="color:#E1E4E8">];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> first </span><span style="color:#F97583">=</span><span style="color:#F97583"> &amp;</span><span style="color:#E1E4E8">v[</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">v</span><span style="color:#F97583">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">6</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;The first element is: {first}&quot;</span><span style="color:#E1E4E8">);</span></span></code></pre>
<p>The borrow checker enforces ownership and reference rules. The above is invalid code because when we borrow v in the first variable it creates an immutable reference, and we aren’t allowed to hold both a mutable and an immutable reference to v.</p>
<blockquote>
<p>This doesn’t work because adding a new element might require allocating new memory and copying the data since the elements are next to each other in memory. If Rust did that the first element will be pointing to deallocated memory.</p>
</blockquote>
<h4 id="iteration">Iteration:</h4>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> v </span><span style="color:#F97583">=</span><span style="color:#B392F0"> vec!</span><span style="color:#E1E4E8">[</span><span style="color:#79B8FF">100</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">32</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">57</span><span style="color:#E1E4E8">];</span></span>
<span class="line"><span style="color:#F97583">for</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">in</span><span style="color:#F97583"> &amp;</span><span style="color:#E1E4E8">v {</span></span>
<span class="line"><span style="color:#B392F0">	println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;{i}&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>If you want to make changes you loop a mutable:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">    let</span><span style="color:#F97583"> mut</span><span style="color:#E1E4E8"> v </span><span style="color:#F97583">=</span><span style="color:#B392F0"> vec!</span><span style="color:#E1E4E8">[</span><span style="color:#79B8FF">100</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">32</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">57</span><span style="color:#E1E4E8">];</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">in</span><span style="color:#F97583"> &amp;mut</span><span style="color:#E1E4E8"> v {</span></span>
<span class="line"><span style="color:#F97583">        *</span><span style="color:#E1E4E8">i </span><span style="color:#F97583">+=</span><span style="color:#79B8FF"> 50</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span></code></pre>
<p>To update the value that the reference refers to we have to dereference it first. We can’t add elements to the vector within the loop because the reference that the for loop holds prevents simultaneous modification. Instead we would have to loop over the indices.</p>
<p><strong>If we really wanted to store different types in the vector</strong> then we could use an enum:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">    enum</span><span style="color:#B392F0"> SpreadsheetCell</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">        Int</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">i32</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#B392F0">        Float</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">f64</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#B392F0">        Text</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">String</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> row </span><span style="color:#F97583">=</span><span style="color:#B392F0"> vec!</span><span style="color:#E1E4E8">[</span></span>
<span class="line"><span style="color:#B392F0">        SpreadsheetCell</span><span style="color:#F97583">::</span><span style="color:#B392F0">Int</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#B392F0">        SpreadsheetCell</span><span style="color:#F97583">::</span><span style="color:#B392F0">Text</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">String</span><span style="color:#F97583">::</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;blue&quot;</span><span style="color:#E1E4E8">)),</span></span>
<span class="line"><span style="color:#B392F0">        SpreadsheetCell</span><span style="color:#F97583">::</span><span style="color:#B392F0">Float</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">10.12</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#E1E4E8">    ];</span></span></code></pre>
<p>Vector memory is freed when it goes out of scope.</p>
<h3 id="string">String</h3>
<p>Strings are a collection of bytes. In Rust the only string type is the string slice <code>&amp;str</code> which is a reference to UTF-8 encoded string data. a string literal is stored in the program binary and are therefore string slices.
The String type is implemented in the Rust standard library as a wrapper around a vector of bytes.
Lots of the same methods are available on a String that are on a Vector e.g. <code>::new()</code>.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#6A737D">// make a string 3 ways:</span></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> data </span><span style="color:#F97583">=</span><span style="color:#9ECBFF"> &quot;initial contents&quot;</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> s </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> data</span><span style="color:#F97583">.</span><span style="color:#B392F0">to_string</span><span style="color:#E1E4E8">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> s </span><span style="color:#F97583">=</span><span style="color:#9ECBFF"> &quot;initial contents&quot;</span><span style="color:#F97583">.</span><span style="color:#B392F0">to_string</span><span style="color:#E1E4E8">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> s </span><span style="color:#F97583">=</span><span style="color:#B392F0"> String</span><span style="color:#F97583">::</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;initial contents&quot;</span><span style="color:#E1E4E8">);</span></span></code></pre>
<p>Like a vector a string can grow in size you can push data into it, or use the + operator or the format! macro for concatenation.
We can append a string slice:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">let</span><span style="color:#F97583"> mut</span><span style="color:#E1E4E8"> s </span><span style="color:#F97583">=</span><span style="color:#B392F0"> String</span><span style="color:#F97583">::</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;foo&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">s</span><span style="color:#F97583">.</span><span style="color:#B392F0">push_str</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;bar&quot;</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">// foobar</span></span>
<span class="line"><span style="color:#6A737D">// the push method takes 1 character</span></span>
<span class="line"><span style="color:#E1E4E8">s</span><span style="color:#F97583">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&#39;!&#39;</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">//foobar!</span></span></code></pre>
<p>Or using the + operator:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> s1 </span><span style="color:#F97583">=</span><span style="color:#B392F0"> String</span><span style="color:#F97583">::</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Hello, &quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> s2 </span><span style="color:#F97583">=</span><span style="color:#B392F0"> String</span><span style="color:#F97583">::</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;world!&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> s3 </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> s1 </span><span style="color:#F97583">+</span><span style="color:#F97583"> &amp;</span><span style="color:#E1E4E8">s2;</span></span></code></pre>
<p>s1 is moved so cannot be used after that point but s2 was borrowed as a reference so can be used. The + operator is implemented like this:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> add</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">self</span><span style="color:#E1E4E8">, s</span><span style="color:#F97583">:</span><span style="color:#F97583"> &amp;</span><span style="color:#B392F0">str</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">-&gt;</span><span style="color:#B392F0"> String</span><span style="color:#E1E4E8"> {</span></span></code></pre>
<p>So we have to make one of the strings a reference. s3 will take ownership of s1 and append s2. If we need to join too many strings it’s cleaner to use <code>format!</code>:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> s1 </span><span style="color:#F97583">=</span><span style="color:#B392F0"> String</span><span style="color:#F97583">::</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;tic&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> s2 </span><span style="color:#F97583">=</span><span style="color:#B392F0"> String</span><span style="color:#F97583">::</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;tac&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> s3 </span><span style="color:#F97583">=</span><span style="color:#B392F0"> String</span><span style="color:#F97583">::</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;toe&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> s </span><span style="color:#F97583">=</span><span style="color:#B392F0"> format!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;{s1}-{s2}-{s3}&quot;</span><span style="color:#E1E4E8">);</span></span></code></pre>
<p>Rust strings do not support indexing because it is stored as a vector of bytes so indexing it will return the byte representation at that position. For non Latin script characters may take more than one byte so if you get the length rust will probably print more than you’d expect.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> hello </span><span style="color:#F97583">=</span><span style="color:#9ECBFF"> &quot;Здравствуйте&quot;</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> s </span><span style="color:#F97583">=</span><span style="color:#F97583"> &amp;</span><span style="color:#E1E4E8">hello[</span><span style="color:#79B8FF">0</span><span style="color:#F97583">..</span><span style="color:#79B8FF">4</span><span style="color:#E1E4E8">]; </span><span style="color:#6A737D">// `Зд`</span></span></code></pre>
<p>Each character in Cyrillic is 2 bytes so indexing the first 4 bytes gives you the first 2 characters. If we want characters rather than bytes we have to be explicit and say <code>hello.chars();</code>.</p>
<h2 id="hashmaps">HashMaps</h2>
<p>The type def for a Hash Table is <code>HashMap&lt;K, V&gt;</code> .
Basic syntax:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">use</span><span style="color:#B392F0"> std</span><span style="color:#F97583">::</span><span style="color:#B392F0">collections</span><span style="color:#F97583">::</span><span style="color:#B392F0">HashMap</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#F97583"> mut</span><span style="color:#E1E4E8"> scores </span><span style="color:#F97583">=</span><span style="color:#B392F0"> HashMap</span><span style="color:#F97583">::</span><span style="color:#B392F0">new</span><span style="color:#E1E4E8">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">scores</span><span style="color:#F97583">.</span><span style="color:#B392F0">insert</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">String</span><span style="color:#F97583">::</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Blue&quot;</span><span style="color:#E1E4E8">), </span><span style="color:#79B8FF">10</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">scores</span><span style="color:#F97583">.</span><span style="color:#B392F0">insert</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">String</span><span style="color:#F97583">::</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Yellow&quot;</span><span style="color:#E1E4E8">), </span><span style="color:#79B8FF">50</span><span style="color:#E1E4E8">);</span></span></code></pre>
<p>Accessing Values:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">use</span><span style="color:#B392F0"> std</span><span style="color:#F97583">::</span><span style="color:#B392F0">collections</span><span style="color:#F97583">::</span><span style="color:#B392F0">HashMap</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#F97583"> mut</span><span style="color:#E1E4E8"> scores </span><span style="color:#F97583">=</span><span style="color:#B392F0"> HashMap</span><span style="color:#F97583">::</span><span style="color:#B392F0">new</span><span style="color:#E1E4E8">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">scores</span><span style="color:#F97583">.</span><span style="color:#B392F0">insert</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">String</span><span style="color:#F97583">::</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Blue&quot;</span><span style="color:#E1E4E8">), </span><span style="color:#79B8FF">10</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">scores</span><span style="color:#F97583">.</span><span style="color:#B392F0">insert</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">String</span><span style="color:#F97583">::</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Yellow&quot;</span><span style="color:#E1E4E8">), </span><span style="color:#79B8FF">50</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> team_name </span><span style="color:#F97583">=</span><span style="color:#B392F0"> String</span><span style="color:#F97583">::</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Blue&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#6A737D">// get returns `Option&lt;&amp;V&gt;`</span></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> score </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> scores</span><span style="color:#F97583">.</span><span style="color:#B392F0">get</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">&amp;</span><span style="color:#E1E4E8">team_name)</span><span style="color:#F97583">.</span><span style="color:#B392F0">copied</span><span style="color:#E1E4E8">()</span><span style="color:#F97583">.</span><span style="color:#B392F0">unwrap_or</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">);</span></span></code></pre>
<p><code>.copied()</code> converts <code>Option&lt;&amp;i32&gt;</code> to <code>Option&lt;i32&gt;</code> then unwrap or to set score to 0 if there is no score for that value.</p>
<p><strong>Loops</strong>:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">for</span><span style="color:#E1E4E8"> (key, value) </span><span style="color:#F97583">in</span><span style="color:#F97583"> &amp;</span><span style="color:#E1E4E8">scores {</span></span>
<span class="line"><span style="color:#B392F0">	println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;{key}: {value}&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>For types which don’t implement  the <code>Copy</code> trait like <code>i32</code> the values are copied into the hash map. For owned values like a String values are moved and the hash map will become the owner.
We can’t insert a reference into the hash map because reference has to be valid for at least as long as the hash map is valid otherwise if it is dereferenced too early and the value will be lost from the hashmap.</p>
<p><strong>Updating</strong>
We could override the values:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">    use</span><span style="color:#B392F0"> std</span><span style="color:#F97583">::</span><span style="color:#B392F0">collections</span><span style="color:#F97583">::</span><span style="color:#B392F0">HashMap</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#F97583"> mut</span><span style="color:#E1E4E8"> scores </span><span style="color:#F97583">=</span><span style="color:#B392F0"> HashMap</span><span style="color:#F97583">::</span><span style="color:#B392F0">new</span><span style="color:#E1E4E8">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">    scores</span><span style="color:#F97583">.</span><span style="color:#B392F0">insert</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">String</span><span style="color:#F97583">::</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Blue&quot;</span><span style="color:#E1E4E8">), </span><span style="color:#79B8FF">10</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">    scores</span><span style="color:#F97583">.</span><span style="color:#B392F0">insert</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">String</span><span style="color:#F97583">::</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Blue&quot;</span><span style="color:#E1E4E8">), </span><span style="color:#79B8FF">25</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">    println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;{:?}&quot;</span><span style="color:#E1E4E8">, scores);</span></span></code></pre>
<p>We can also use Or_insert to only add a value if a key doesn’t already exist:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583"> use</span><span style="color:#B392F0"> std</span><span style="color:#F97583">::</span><span style="color:#B392F0">collections</span><span style="color:#F97583">::</span><span style="color:#B392F0">HashMap</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#F97583"> mut</span><span style="color:#E1E4E8"> scores </span><span style="color:#F97583">=</span><span style="color:#B392F0"> HashMap</span><span style="color:#F97583">::</span><span style="color:#B392F0">new</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    scores</span><span style="color:#F97583">.</span><span style="color:#B392F0">insert</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">String</span><span style="color:#F97583">::</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Blue&quot;</span><span style="color:#E1E4E8">), </span><span style="color:#79B8FF">10</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">    scores</span><span style="color:#F97583">.</span><span style="color:#B392F0">entry</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">String</span><span style="color:#F97583">::</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Yellow&quot;</span><span style="color:#E1E4E8">))</span><span style="color:#F97583">.</span><span style="color:#B392F0">or_insert</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">50</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">    scores</span><span style="color:#F97583">.</span><span style="color:#B392F0">entry</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">String</span><span style="color:#F97583">::</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Blue&quot;</span><span style="color:#E1E4E8">))</span><span style="color:#F97583">.</span><span style="color:#B392F0">or_insert</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">50</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">    println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;{:?}&quot;</span><span style="color:#E1E4E8">, scores);</span></span></code></pre>
<p>Counting Frequency:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">    use</span><span style="color:#B392F0"> std</span><span style="color:#F97583">::</span><span style="color:#B392F0">collections</span><span style="color:#F97583">::</span><span style="color:#B392F0">HashMap</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> text </span><span style="color:#F97583">=</span><span style="color:#9ECBFF"> &quot;hello world wonderful world&quot;</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#F97583"> mut</span><span style="color:#E1E4E8"> map </span><span style="color:#F97583">=</span><span style="color:#B392F0"> HashMap</span><span style="color:#F97583">::</span><span style="color:#B392F0">new</span><span style="color:#E1E4E8">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> word </span><span style="color:#F97583">in</span><span style="color:#E1E4E8"> text</span><span style="color:#F97583">.</span><span style="color:#B392F0">split_whitespace</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">        let</span><span style="color:#E1E4E8"> count </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> map</span><span style="color:#F97583">.</span><span style="color:#B392F0">entry</span><span style="color:#E1E4E8">(word)</span><span style="color:#F97583">.</span><span style="color:#B392F0">or_insert</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">        *</span><span style="color:#E1E4E8">count </span><span style="color:#F97583">+=</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#B392F0">    println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;{:?}&quot;</span><span style="color:#E1E4E8">, map);</span></span></code></pre>
<p>We have to dereference count in order to update it.
Rust uses the SipHash hashing function because it provides DoS resistance.</p>
<h2 id="error-handling">Error Handling</h2>
<p>Rust errors are grouped into <strong>recoverable</strong> (reported) and <strong>unrecoverable</strong> (stop execution).
Unlike most languages rust doesn’t have exceptions instead it has the <code>Result&lt;T, E&gt;</code> type for recoverable error and then the <code>panic!</code> macro stops execution.</p>
<p>In C if you read data from an array at a position that is beyond the array you might get a return of something that’s at that memory location, which doesn’t belong to that structure, this is a <em>buffer overread</em>.</p>
<p>If we run our program using <code>RUST_BACKTRACE=1 cargo run</code> we will get a trackback when the program panics.</p>
<p>The Result type is an Enum which looks like this:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">enum</span><span style="color:#B392F0"> Result</span><span style="color:#E1E4E8">&lt;</span><span style="color:#B392F0">T</span><span style="color:#E1E4E8">, </span><span style="color:#B392F0">E</span><span style="color:#E1E4E8">&gt; {</span></span>
<span class="line"><span style="color:#B392F0">	Ok</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">T</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#B392F0">	Err</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">E</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Lots of functions return this in case they fail for instance file reading:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">use</span><span style="color:#B392F0"> std</span><span style="color:#F97583">::</span><span style="color:#B392F0">fs</span><span style="color:#F97583">::</span><span style="color:#B392F0">File</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">	let</span><span style="color:#E1E4E8"> greeting_file_result </span><span style="color:#F97583">=</span><span style="color:#B392F0"> File</span><span style="color:#F97583">::</span><span style="color:#B392F0">open</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;hello.txt&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">	let</span><span style="color:#E1E4E8"> greetings_file </span><span style="color:#F97583">=</span><span style="color:#F97583"> match</span><span style="color:#E1E4E8"> greeting_file_result {</span></span>
<span class="line"><span style="color:#B392F0">		Ok</span><span style="color:#E1E4E8">(file) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> file,</span></span>
<span class="line"><span style="color:#B392F0">		Err</span><span style="color:#E1E4E8">(error) </span><span style="color:#F97583">=&gt;</span><span style="color:#B392F0"> panic!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Problem Opening File: {:?}&quot;</span><span style="color:#E1E4E8">, error),</span></span>
<span class="line"><span style="color:#E1E4E8">	};</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>We can also match specific errors:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">use</span><span style="color:#B392F0"> std</span><span style="color:#F97583">::</span><span style="color:#B392F0">fs</span><span style="color:#F97583">::</span><span style="color:#B392F0">File</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">use</span><span style="color:#B392F0"> std</span><span style="color:#F97583">::</span><span style="color:#B392F0">io</span><span style="color:#F97583">::</span><span style="color:#B392F0">ErrorKind</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> greeting_file_result </span><span style="color:#F97583">=</span><span style="color:#B392F0"> File</span><span style="color:#F97583">::</span><span style="color:#B392F0">open</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;hello.txt&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> greeting_file </span><span style="color:#F97583">=</span><span style="color:#F97583"> match</span><span style="color:#E1E4E8"> greeting_file_result {</span></span>
<span class="line"><span style="color:#B392F0">        Ok</span><span style="color:#E1E4E8">(file) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> file,</span></span>
<span class="line"><span style="color:#B392F0">        Err</span><span style="color:#E1E4E8">(error) </span><span style="color:#F97583">=&gt;</span><span style="color:#F97583"> match</span><span style="color:#E1E4E8"> error</span><span style="color:#F97583">.</span><span style="color:#B392F0">kind</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#B392F0">            ErrorKind</span><span style="color:#F97583">::</span><span style="color:#B392F0">NotFound</span><span style="color:#F97583"> =&gt;</span><span style="color:#F97583"> match</span><span style="color:#B392F0"> File</span><span style="color:#F97583">::</span><span style="color:#B392F0">create</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;hello.txt&quot;</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#B392F0">                Ok</span><span style="color:#E1E4E8">(fc) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> fc,</span></span>
<span class="line"><span style="color:#B392F0">                Err</span><span style="color:#E1E4E8">(e) </span><span style="color:#F97583">=&gt;</span><span style="color:#B392F0"> panic!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Problem creating the file: {:?}&quot;</span><span style="color:#E1E4E8">, e),</span></span>
<span class="line"><span style="color:#E1E4E8">            },</span></span>
<span class="line"><span style="color:#E1E4E8">            other_error </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">                panic!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Problem opening the file: {:?}&quot;</span><span style="color:#E1E4E8">, other_error);</span></span>
<span class="line"><span style="color:#E1E4E8">            }</span></span>
<span class="line"><span style="color:#E1E4E8">        },</span></span>
<span class="line"><span style="color:#E1E4E8">    };</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>We can rewrite this using a closure to make it cleaner:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">use</span><span style="color:#B392F0"> std</span><span style="color:#F97583">::</span><span style="color:#B392F0">fs</span><span style="color:#F97583">::</span><span style="color:#B392F0">File</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">use</span><span style="color:#B392F0"> std</span><span style="color:#F97583">::</span><span style="color:#B392F0">io</span><span style="color:#F97583">::</span><span style="color:#B392F0">ErrorKind</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> greeting_file </span><span style="color:#F97583">=</span><span style="color:#B392F0"> File</span><span style="color:#F97583">::</span><span style="color:#B392F0">open</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;hello.txt&quot;</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">.</span><span style="color:#B392F0">unwrap_or_else</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">|</span><span style="color:#E1E4E8">error</span><span style="color:#F97583">|</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> error</span><span style="color:#F97583">.</span><span style="color:#B392F0">kind</span><span style="color:#E1E4E8">() </span><span style="color:#F97583">==</span><span style="color:#B392F0"> ErrorKind</span><span style="color:#F97583">::</span><span style="color:#B392F0">NotFound</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">            File</span><span style="color:#F97583">::</span><span style="color:#B392F0">create</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;hello.txt&quot;</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">.</span><span style="color:#B392F0">unwrap_or_else</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">|</span><span style="color:#E1E4E8">error</span><span style="color:#F97583">|</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">                panic!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Problem creating the file: {:?}&quot;</span><span style="color:#E1E4E8">, error);</span></span>
<span class="line"><span style="color:#E1E4E8">            })</span></span>
<span class="line"><span style="color:#E1E4E8">        } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">            panic!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Problem opening the file: {:?}&quot;</span><span style="color:#E1E4E8">, error);</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#E1E4E8">    });</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p><strong>Shortcuts</strong>
unwrap and expect are shortcuts to panic.
<code>unwrap</code>
is a shortcut to panic it is implemented just like match. If the Result is Ok we return the value inside Ok and if the result is Err we call panic.
<code>expect</code>
like unwrap but it takes a message parameter which is passed to panic.</p>
<h5 id="error-propagation">Error Propagation</h5>
<p>If a function is running code which has the potential to error instead of handing the error there you could return the error and let the calling function deal with it. This is called <strong>propagating</strong> the error.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">use</span><span style="color:#B392F0"> std</span><span style="color:#F97583">::</span><span style="color:#B392F0">fs</span><span style="color:#F97583">::</span><span style="color:#B392F0">File</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">use</span><span style="color:#B392F0"> std</span><span style="color:#F97583">::</span><span style="color:#B392F0">io</span><span style="color:#F97583">::</span><span style="color:#E1E4E8">{</span><span style="color:#79B8FF">self</span><span style="color:#E1E4E8">, </span><span style="color:#B392F0">Read</span><span style="color:#E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> read_username_from_file</span><span style="color:#E1E4E8">() </span><span style="color:#F97583">-&gt;</span><span style="color:#B392F0"> Result</span><span style="color:#E1E4E8">&lt;</span><span style="color:#B392F0">String</span><span style="color:#E1E4E8">, io</span><span style="color:#F97583">::</span><span style="color:#B392F0">Error</span><span style="color:#E1E4E8">&gt; {</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> username_file_result </span><span style="color:#F97583">=</span><span style="color:#B392F0"> File</span><span style="color:#F97583">::</span><span style="color:#B392F0">open</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;hello.txt&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#F97583"> mut</span><span style="color:#E1E4E8"> username_file </span><span style="color:#F97583">=</span><span style="color:#F97583"> match</span><span style="color:#E1E4E8"> username_file_result {</span></span>
<span class="line"><span style="color:#B392F0">        Ok</span><span style="color:#E1E4E8">(file) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> file,</span></span>
<span class="line"><span style="color:#B392F0">        Err</span><span style="color:#E1E4E8">(e) </span><span style="color:#F97583">=&gt;</span><span style="color:#F97583"> return</span><span style="color:#B392F0"> Err</span><span style="color:#E1E4E8">(e),</span></span>
<span class="line"><span style="color:#E1E4E8">    };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#F97583"> mut</span><span style="color:#E1E4E8"> username </span><span style="color:#F97583">=</span><span style="color:#B392F0"> String</span><span style="color:#F97583">::</span><span style="color:#B392F0">new</span><span style="color:#E1E4E8">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    match</span><span style="color:#E1E4E8"> username_file</span><span style="color:#F97583">.</span><span style="color:#B392F0">read_to_string</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">&amp;mut</span><span style="color:#E1E4E8"> username) {</span></span>
<span class="line"><span style="color:#B392F0">        Ok</span><span style="color:#E1E4E8">(_) </span><span style="color:#F97583">=&gt;</span><span style="color:#B392F0"> Ok</span><span style="color:#E1E4E8">(username),</span></span>
<span class="line"><span style="color:#B392F0">        Err</span><span style="color:#E1E4E8">(e) </span><span style="color:#F97583">=&gt;</span><span style="color:#B392F0"> Err</span><span style="color:#E1E4E8">(e),</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Here we try to read a file and if there is an error we return the error to whatever function called the <code>read_username_from_file</code> function.</p>
<ul>
<li>The return type of the function is <code>Result&lt;String, io:error&gt;</code> those are concrete types which fill the T and E type parameters.
<ul>
<li>With no error we return <code>Ok(String)</code></li>
<li>if errors then the calling code with get the Err (used <code>io::Error</code> because that is the return type of <code>File::open</code> and <code>read_to_string</code>.</li>
</ul>
</li>
<li>If successful then the the file becomes the value of <code>username_file</code> and the function keeps going.
<ul>
<li>A new string is created and <code>read_to_string</code> is called puts the file contents on the username.
<ul>
<li>This also returns a result so we match it.</li>
<li>Here we don’t need the return keyword since it’s the last expression of the function.</li>
</ul>
</li>
</ul>
</li>
<li>If Err then instead of panicking we use the <code>return</code> keyword to return early.
The thing that calls <code>read_username_from_file</code> then has to deal with the errors.</li>
</ul>
<p>This pattern is so common that Rust has a shortcut for it:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">use</span><span style="color:#B392F0"> std</span><span style="color:#F97583">::</span><span style="color:#B392F0">fs</span><span style="color:#F97583">::</span><span style="color:#B392F0">File</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">use</span><span style="color:#B392F0"> std</span><span style="color:#F97583">::</span><span style="color:#B392F0">io</span><span style="color:#F97583">::</span><span style="color:#E1E4E8">{</span><span style="color:#79B8FF">self</span><span style="color:#E1E4E8">, </span><span style="color:#B392F0">Read</span><span style="color:#E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> read_username_from_file</span><span style="color:#E1E4E8">() </span><span style="color:#F97583">-&gt;</span><span style="color:#B392F0"> Result</span><span style="color:#E1E4E8">&lt;</span><span style="color:#B392F0">String</span><span style="color:#E1E4E8">, io</span><span style="color:#F97583">::</span><span style="color:#B392F0">Error</span><span style="color:#E1E4E8">&gt; {</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#F97583"> mut</span><span style="color:#E1E4E8"> username_file </span><span style="color:#F97583">=</span><span style="color:#B392F0"> File</span><span style="color:#F97583">::</span><span style="color:#B392F0">open</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;hello.txt&quot;</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">?</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#F97583"> mut</span><span style="color:#E1E4E8"> username </span><span style="color:#F97583">=</span><span style="color:#B392F0"> String</span><span style="color:#F97583">::</span><span style="color:#B392F0">new</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    username_file</span><span style="color:#F97583">.</span><span style="color:#B392F0">read_to_string</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">&amp;mut</span><span style="color:#E1E4E8"> username)</span><span style="color:#F97583">?</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#B392F0">    Ok</span><span style="color:#E1E4E8">(username)</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>This will do almost the same as the code before.</p>
<blockquote>
<p>error values that have the <code>?</code> operator called on them go through the <code>from</code> function, defined in the <code>From</code> trait in the standard library, which is used to convert values from one type into another.</p>
</blockquote>
<p>? will also convert any error received to the error type specified in the return type via the call to from.</p>
<p>We could also chain things to make that even shorter:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">use</span><span style="color:#B392F0"> std</span><span style="color:#F97583">::</span><span style="color:#B392F0">fs</span><span style="color:#F97583">::</span><span style="color:#B392F0">File</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">use</span><span style="color:#B392F0"> std</span><span style="color:#F97583">::</span><span style="color:#B392F0">io</span><span style="color:#F97583">::</span><span style="color:#E1E4E8">{</span><span style="color:#79B8FF">self</span><span style="color:#E1E4E8">, </span><span style="color:#B392F0">Read</span><span style="color:#E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> read_username_from_file</span><span style="color:#E1E4E8">() </span><span style="color:#F97583">-&gt;</span><span style="color:#B392F0"> Result</span><span style="color:#E1E4E8">&lt;</span><span style="color:#B392F0">String</span><span style="color:#E1E4E8">, io</span><span style="color:#F97583">::</span><span style="color:#B392F0">Error</span><span style="color:#E1E4E8">&gt; {</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#F97583"> mut</span><span style="color:#E1E4E8"> username </span><span style="color:#F97583">=</span><span style="color:#B392F0"> String</span><span style="color:#F97583">::</span><span style="color:#B392F0">new</span><span style="color:#E1E4E8">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">    File</span><span style="color:#F97583">::</span><span style="color:#B392F0">open</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;hello.txt&quot;</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">?.</span><span style="color:#B392F0">read_to_string</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">&amp;mut</span><span style="color:#E1E4E8"> username)</span><span style="color:#F97583">?</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">    Ok</span><span style="color:#E1E4E8">(username)</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>This is also a very common operation so we have a function for it in the fs module of the standard library:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">use</span><span style="color:#B392F0"> std</span><span style="color:#F97583">::</span><span style="color:#E1E4E8">fs;</span></span>
<span class="line"><span style="color:#F97583">use</span><span style="color:#B392F0"> std</span><span style="color:#F97583">::</span><span style="color:#E1E4E8">io;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> read_username_from_file</span><span style="color:#E1E4E8">() </span><span style="color:#F97583">-&gt;</span><span style="color:#B392F0"> Result</span><span style="color:#E1E4E8">&lt;</span><span style="color:#B392F0">String</span><span style="color:#E1E4E8">, io</span><span style="color:#F97583">::</span><span style="color:#B392F0">Error</span><span style="color:#E1E4E8">&gt; {</span></span>
<span class="line"><span style="color:#B392F0">    fs</span><span style="color:#F97583">::</span><span style="color:#B392F0">read_to_string</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;hello.txt&quot;</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<blockquote>
<p>The <code>?</code> operator can only be used in functions whose return type is compatible with the value the <code>?</code> is used on.</p>
</blockquote>
<ul>
<li>We can use a Option return type</li>
<li>Or a Result return type</li>
</ul>
<p>Use Panic! when you are writing examples to demonstrate a concept, prototype or in tests.
Also when calling external code which is out of your control. When you expect a failure it is more appropriate to return to Result.</p>
<h2 id="generic-types-traits-and-lifetimes">Generic Types, Traits and Lifetimes.</h2>
<p>We use generics to create function signatures or structs which can be used on many different concrete types.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> largest</span><span style="color:#E1E4E8">&lt;</span><span style="color:#B392F0">T</span><span style="color:#E1E4E8">&gt;(list</span><span style="color:#F97583">:</span><span style="color:#F97583"> &amp;</span><span style="color:#E1E4E8">[</span><span style="color:#B392F0">T</span><span style="color:#E1E4E8">]) </span><span style="color:#F97583">-&gt;</span><span style="color:#F97583"> &amp;</span><span style="color:#B392F0">T</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#F97583"> mut</span><span style="color:#E1E4E8"> largest </span><span style="color:#F97583">=</span><span style="color:#F97583"> &amp;</span><span style="color:#E1E4E8">list[</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> item </span><span style="color:#F97583">in</span><span style="color:#E1E4E8"> list {</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> item </span><span style="color:#F97583">&gt;</span><span style="color:#E1E4E8"> largest {</span></span>
<span class="line"><span style="color:#E1E4E8">            largest </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> item;</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">    largest</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Instead of defining a largest function for all different types we can use a generic type to make it work for many different types. This function won’t work right now since not all types implement comparisons instead we have to restrict to those that do:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> largest</span><span style="color:#E1E4E8">&lt;</span><span style="color:#B392F0">T</span><span style="color:#F97583">:</span><span style="color:#B392F0"> std</span><span style="color:#F97583">::</span><span style="color:#B392F0">cmp</span><span style="color:#F97583">::</span><span style="color:#B392F0">PartialOrd</span><span style="color:#E1E4E8">&gt;(list</span><span style="color:#F97583">:</span><span style="color:#F97583"> &amp;</span><span style="color:#E1E4E8">[</span><span style="color:#B392F0">T</span><span style="color:#E1E4E8">]) </span><span style="color:#F97583">-&gt;</span><span style="color:#F97583"> &amp;</span><span style="color:#B392F0">T</span><span style="color:#E1E4E8"> {}</span></span></code></pre>
<p>A generic struct could look like this:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">struct</span><span style="color:#B392F0"> Point</span><span style="color:#E1E4E8">&lt;</span><span style="color:#B392F0">T</span><span style="color:#E1E4E8">&gt; {</span></span>
<span class="line"><span style="color:#E1E4E8">    x</span><span style="color:#F97583">:</span><span style="color:#B392F0"> T</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">    y</span><span style="color:#F97583">:</span><span style="color:#B392F0"> T</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> integer </span><span style="color:#F97583">=</span><span style="color:#B392F0"> Point</span><span style="color:#E1E4E8"> { x</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> 5</span><span style="color:#E1E4E8">, y</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> 10</span><span style="color:#E1E4E8"> };</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> float </span><span style="color:#F97583">=</span><span style="color:#B392F0"> Point</span><span style="color:#E1E4E8"> { x</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> 1.0</span><span style="color:#E1E4E8">, y</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> 4.0</span><span style="color:#E1E4E8"> };</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p><strong>Note</strong>: Since the type is T both x and y have to be the same type. If you want them to be different you have to define another type parameter:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">struct</span><span style="color:#B392F0"> Point</span><span style="color:#E1E4E8">&lt;</span><span style="color:#B392F0">T</span><span style="color:#E1E4E8">, </span><span style="color:#B392F0">U</span><span style="color:#E1E4E8">&gt; {</span></span>
<span class="line"><span style="color:#E1E4E8">    x</span><span style="color:#F97583">:</span><span style="color:#B392F0"> T</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">    y</span><span style="color:#F97583">:</span><span style="color:#B392F0"> U</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> both_integer </span><span style="color:#F97583">=</span><span style="color:#B392F0"> Point</span><span style="color:#E1E4E8"> { x</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> 5</span><span style="color:#E1E4E8">, y</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> 10</span><span style="color:#E1E4E8"> };</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> both_float </span><span style="color:#F97583">=</span><span style="color:#B392F0"> Point</span><span style="color:#E1E4E8"> { x</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> 1.0</span><span style="color:#E1E4E8">, y</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> 4.0</span><span style="color:#E1E4E8"> };</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> integer_and_float </span><span style="color:#F97583">=</span><span style="color:#B392F0"> Point</span><span style="color:#E1E4E8"> { x</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> 5</span><span style="color:#E1E4E8">, y</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> 4.0</span><span style="color:#E1E4E8"> };</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>enums can also have generics like in <code>Result&lt;T, E&gt;</code> and <code>Option&lt;T&gt;</code>.</p>
<p>Similarly in method definitions:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">struct</span><span style="color:#B392F0"> Point</span><span style="color:#E1E4E8">&lt;</span><span style="color:#B392F0">T</span><span style="color:#E1E4E8">&gt; {</span></span>
<span class="line"><span style="color:#E1E4E8">    x</span><span style="color:#F97583">:</span><span style="color:#B392F0"> T</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">    y</span><span style="color:#F97583">:</span><span style="color:#B392F0"> T</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">impl</span><span style="color:#E1E4E8">&lt;</span><span style="color:#B392F0">T</span><span style="color:#E1E4E8">&gt; </span><span style="color:#B392F0">Point</span><span style="color:#E1E4E8">&lt;</span><span style="color:#B392F0">T</span><span style="color:#E1E4E8">&gt; {</span></span>
<span class="line"><span style="color:#F97583">    fn</span><span style="color:#B392F0"> x</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">&amp;</span><span style="color:#79B8FF">self</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">-&gt;</span><span style="color:#F97583"> &amp;</span><span style="color:#B392F0">T</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">        &amp;</span><span style="color:#79B8FF">self</span><span style="color:#F97583">.</span><span style="color:#E1E4E8">x</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> p </span><span style="color:#F97583">=</span><span style="color:#B392F0"> Point</span><span style="color:#E1E4E8"> { x</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> 5</span><span style="color:#E1E4E8">, y</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> 10</span><span style="color:#E1E4E8"> };</span></span>
<span class="line"><span style="color:#B392F0">    println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;p.x = {}&quot;</span><span style="color:#E1E4E8">, p</span><span style="color:#F97583">.</span><span style="color:#B392F0">x</span><span style="color:#E1E4E8">());</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>To optimise this rust uses <strong>monomorphization</strong> which turns the generics into concrete types based on how you call them.</p>
<h3 id="traits">Traits</h3>
<p>A trait defines shared behaviour between different types. Traits define shared behaviour in an abstract way using generics giving a certain behaviour to a certain type.</p>
<p>A type’s behaviour consists of methods we call on the type, different types often share the same behaviour. Traits are a way to define this shared behaviour.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">pub</span><span style="color:#F97583"> trait</span><span style="color:#B392F0"> Summary</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">	fn</span><span style="color:#B392F0"> summarize</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">&amp;</span><span style="color:#79B8FF">self</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">-&gt;</span><span style="color:#B392F0"> String</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>In this case we use a semi colon at the end of the function so that each type which implements this has to define its own definition for summarize.
<strong>Implementing a Trait on a type</strong></p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">pub</span><span style="color:#F97583"> struct</span><span style="color:#B392F0"> NewsArticle</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    pub</span><span style="color:#E1E4E8"> headline</span><span style="color:#F97583">:</span><span style="color:#B392F0"> String</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#F97583">    pub</span><span style="color:#E1E4E8"> location</span><span style="color:#F97583">:</span><span style="color:#B392F0"> String</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#F97583">    pub</span><span style="color:#E1E4E8"> author</span><span style="color:#F97583">:</span><span style="color:#B392F0"> String</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#F97583">    pub</span><span style="color:#E1E4E8"> content</span><span style="color:#F97583">:</span><span style="color:#B392F0"> String</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">impl</span><span style="color:#B392F0"> Summary</span><span style="color:#F97583"> for</span><span style="color:#B392F0"> NewsArticle</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    fn</span><span style="color:#B392F0"> summarize</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">&amp;</span><span style="color:#79B8FF">self</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">-&gt;</span><span style="color:#B392F0"> String</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">        format!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;{}, by {} ({})&quot;</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">self</span><span style="color:#F97583">.</span><span style="color:#E1E4E8">headline, </span><span style="color:#79B8FF">self</span><span style="color:#F97583">.</span><span style="color:#E1E4E8">author, </span><span style="color:#79B8FF">self</span><span style="color:#F97583">.</span><span style="color:#E1E4E8">location)</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>The <code>for</code> keyword is used to implement a trait on a type. Now a NewsArticle or any other type that implements this can call it like a method <code>instance.summarize()</code>.</p>
<p>Traits can also have default implementations:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">pub</span><span style="color:#F97583"> trait</span><span style="color:#B392F0"> Summary</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    fn</span><span style="color:#B392F0"> summarize</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">&amp;</span><span style="color:#79B8FF">self</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">-&gt;</span><span style="color:#B392F0"> String</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">        String</span><span style="color:#F97583">::</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;(Read more...)&quot;</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Then to use the default implementation to summarize instances of <code>NewsArticle</code>, we specify an empty <code>impl</code> block with <code>impl Summary for NewsArticle {}</code>.</p>
<p>Calls to summarize with no implementation will call the default implementation.</p>
<p>Default implementations can call methods which don’t have default implementations.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">pub</span><span style="color:#F97583"> trait</span><span style="color:#B392F0"> Summary</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    fn</span><span style="color:#B392F0"> summarize_author</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">&amp;</span><span style="color:#79B8FF">self</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">-&gt;</span><span style="color:#B392F0"> String</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    fn</span><span style="color:#B392F0"> summarize</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">&amp;</span><span style="color:#79B8FF">self</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">-&gt;</span><span style="color:#B392F0"> String</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">        format!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;(Read more from {}...)&quot;</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">self</span><span style="color:#F97583">.</span><span style="color:#B392F0">summarize_author</span><span style="color:#E1E4E8">())</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>To use this we only need to define <code>summarize_author</code></p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">impl</span><span style="color:#B392F0"> Summary</span><span style="color:#F97583"> for</span><span style="color:#B392F0"> Tweet</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    fn</span><span style="color:#B392F0"> summarize_author</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">&amp;</span><span style="color:#79B8FF">self</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">-&gt;</span><span style="color:#B392F0"> String</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">        format!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;@{}&quot;</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">self</span><span style="color:#F97583">.</span><span style="color:#E1E4E8">username)</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p><strong>Traits can be parameters</strong>
Traits can be used to define functions which can accept many different types.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">pub</span><span style="color:#F97583"> fn</span><span style="color:#B392F0"> notify</span><span style="color:#E1E4E8">(item</span><span style="color:#F97583">:</span><span style="color:#F97583"> &amp;impl</span><span style="color:#B392F0"> Summary</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#B392F0">    println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Breaking news! {}&quot;</span><span style="color:#E1E4E8">, item</span><span style="color:#F97583">.</span><span style="color:#B392F0">summarize</span><span style="color:#E1E4E8">());</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Here the function takes an item but the only valid items are the ones which implement Summary.
The above code is syntax sugar for creating a boundary:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">pub</span><span style="color:#F97583"> fn</span><span style="color:#B392F0"> notify</span><span style="color:#E1E4E8">&lt;</span><span style="color:#B392F0">T</span><span style="color:#F97583">:</span><span style="color:#B392F0"> Summary</span><span style="color:#E1E4E8">&gt;(item</span><span style="color:#F97583">:</span><span style="color:#F97583"> &amp;</span><span style="color:#B392F0">T</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#B392F0">	println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Breaking news! {}&quot;</span><span style="color:#E1E4E8">, item</span><span style="color:#F97583">.</span><span style="color:#B392F0">summarize</span><span style="color:#E1E4E8">());</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>This is more verbose we place trait bounds on the type with a declaration of a generic type.
This is useful when both types implement the same Type:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">pub</span><span style="color:#F97583"> fn</span><span style="color:#B392F0"> notify</span><span style="color:#E1E4E8">(item1</span><span style="color:#F97583">:</span><span style="color:#F97583"> &amp;impl</span><span style="color:#B392F0"> Summary</span><span style="color:#E1E4E8">, item2</span><span style="color:#F97583">:</span><span style="color:#F97583"> &amp;impl</span><span style="color:#B392F0"> Summary</span><span style="color:#E1E4E8">) {</span></span></code></pre>
<p>VS</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">pub</span><span style="color:#F97583"> fn</span><span style="color:#B392F0"> notify</span><span style="color:#E1E4E8">&lt;</span><span style="color:#B392F0">T</span><span style="color:#F97583">:</span><span style="color:#B392F0"> Summary</span><span style="color:#E1E4E8">&gt;(item1</span><span style="color:#F97583">:</span><span style="color:#F97583"> &amp;</span><span style="color:#B392F0">T</span><span style="color:#E1E4E8">, item2</span><span style="color:#F97583">:</span><span style="color:#F97583"> &amp;</span><span style="color:#B392F0">T</span><span style="color:#E1E4E8">) {</span></span></code></pre>
<p><strong>We can also define multiple trait bounds</strong></p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">pub</span><span style="color:#F97583"> fn</span><span style="color:#B392F0"> notify</span><span style="color:#E1E4E8">(item</span><span style="color:#F97583">:</span><span style="color:#F97583"> &amp;</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">impl</span><span style="color:#B392F0"> Summary</span><span style="color:#F97583"> +</span><span style="color:#B392F0"> Display</span><span style="color:#E1E4E8">)) {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">pub</span><span style="color:#F97583"> fn</span><span style="color:#B392F0"> notify</span><span style="color:#E1E4E8">&lt;</span><span style="color:#B392F0">T</span><span style="color:#F97583">:</span><span style="color:#B392F0"> Summary</span><span style="color:#F97583"> +</span><span style="color:#B392F0"> Display</span><span style="color:#E1E4E8">&gt;(item</span><span style="color:#F97583">:</span><span style="color:#F97583"> &amp;</span><span style="color:#B392F0">T</span><span style="color:#E1E4E8">) {</span></span></code></pre>
<p><em>Using Where to clean up traits</em></p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> some_function</span><span style="color:#E1E4E8">&lt;</span><span style="color:#B392F0">T</span><span style="color:#F97583">:</span><span style="color:#B392F0"> Display</span><span style="color:#F97583"> +</span><span style="color:#B392F0"> Clone</span><span style="color:#E1E4E8">, </span><span style="color:#B392F0">U</span><span style="color:#F97583">:</span><span style="color:#B392F0"> Clone</span><span style="color:#F97583"> +</span><span style="color:#B392F0"> Debug</span><span style="color:#E1E4E8">&gt;(t</span><span style="color:#F97583">:</span><span style="color:#F97583"> &amp;</span><span style="color:#B392F0">T</span><span style="color:#E1E4E8">, u</span><span style="color:#F97583">:</span><span style="color:#F97583"> &amp;</span><span style="color:#B392F0">U</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">-&gt;</span><span style="color:#B392F0"> i32</span><span style="color:#E1E4E8"> {</span></span></code></pre>
<p>we can use a <code>where</code> clause, like this:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> some_function</span><span style="color:#E1E4E8">&lt;</span><span style="color:#B392F0">T</span><span style="color:#E1E4E8">, </span><span style="color:#B392F0">U</span><span style="color:#E1E4E8">&gt;(t</span><span style="color:#F97583">:</span><span style="color:#F97583"> &amp;</span><span style="color:#B392F0">T</span><span style="color:#E1E4E8">, u</span><span style="color:#F97583">:</span><span style="color:#F97583"> &amp;</span><span style="color:#B392F0">U</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">-&gt;</span><span style="color:#B392F0"> i32</span></span>
<span class="line"><span style="color:#F97583">where</span></span>
<span class="line"><span style="color:#B392F0">    T</span><span style="color:#F97583">:</span><span style="color:#B392F0"> Display</span><span style="color:#F97583"> +</span><span style="color:#B392F0"> Clone</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#B392F0">    U</span><span style="color:#F97583">:</span><span style="color:#B392F0"> Clone</span><span style="color:#F97583"> +</span><span style="color:#B392F0"> Debug</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">{</span></span></code></pre>
<p>Return types can also implement traits:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> returns_summarizable</span><span style="color:#E1E4E8">() </span><span style="color:#F97583">-&gt;</span><span style="color:#F97583"> impl</span><span style="color:#B392F0"> Summary</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">    Tweet</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">        username</span><span style="color:#F97583">:</span><span style="color:#B392F0"> String</span><span style="color:#F97583">::</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;horse_ebooks&quot;</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#E1E4E8">        content</span><span style="color:#F97583">:</span><span style="color:#B392F0"> String</span><span style="color:#F97583">::</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#9ECBFF">            &quot;of course, as you probably already know, people&quot;</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">        ),</span></span>
<span class="line"><span style="color:#E1E4E8">        reply</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> false</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">        retweet</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> false</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<h3 id="lifetimes">Lifetimes</h3>
<p>Lifetimes are generics which ensure that a reference is valid for as long as we need it to be. The lifetime is normally inferred (while the variable is in scope it’s valid).</p>
<p><strong>A Dangling Reference</strong></p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> r;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">    {</span></span>
<span class="line"><span style="color:#F97583">        let</span><span style="color:#E1E4E8"> x </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 5</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">        r </span><span style="color:#F97583">=</span><span style="color:#F97583"> &amp;</span><span style="color:#E1E4E8">x;</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">    println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;r: {}&quot;</span><span style="color:#E1E4E8">, r);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>This is code snippet we are attempting to print r which was set to a reference in the inner scope. The value was dropped when it left the scope and so rust will error saying that the borrowed value didn’t live long enough to be printed (since it was dropped).
Otherwise r would be referencing deallocated memory.</p>
<p>The Rust borrow checker compares scopes to determine if borrowed values are valid. Internally rust will annotate life times for all variables lets call then a’ and b’ it will then compare the lifetimes of both at compile time and error if b’ if shorter than a’ because the subject of the reference doesn’t live as long as the reference.</p>
<p><strong>Data has to have a longer lifetime than its reference otherwise the reference will point to nothing and will dangle.</strong></p>
<p>When we write a function like this:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> longest</span><span style="color:#E1E4E8">(x</span><span style="color:#F97583">:</span><span style="color:#F97583"> &amp;</span><span style="color:#B392F0">str</span><span style="color:#E1E4E8">, y</span><span style="color:#F97583">:</span><span style="color:#F97583"> &amp;</span><span style="color:#B392F0">str</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">-&gt;</span><span style="color:#F97583"> &amp;</span><span style="color:#B392F0">str</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> x</span><span style="color:#F97583">.</span><span style="color:#B392F0">len</span><span style="color:#E1E4E8">() &gt; y</span><span style="color:#F97583">.</span><span style="color:#B392F0">len</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#E1E4E8">        x</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">        y</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Where we want to return the longest of two slices, Rust will error because we didn’t specify if the return slice is referring to x or y.</p>
<p>Lifetimes are denoted using an ’ with a letter. Normally a to show the first lifetime.  On their own they have no meaning they are only there to tell rust how different things relate to each other.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> longest</span><span style="color:#E1E4E8">&lt;&#39;</span><span style="color:#B392F0">a</span><span style="color:#E1E4E8">&gt;(x</span><span style="color:#F97583">:</span><span style="color:#F97583"> &amp;</span><span style="color:#E1E4E8">&#39;</span><span style="color:#B392F0">a</span><span style="color:#B392F0"> str</span><span style="color:#E1E4E8">, y</span><span style="color:#F97583">:</span><span style="color:#F97583"> &amp;</span><span style="color:#E1E4E8">&#39;</span><span style="color:#B392F0">a</span><span style="color:#B392F0"> str</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">-&gt;</span><span style="color:#F97583"> &amp;</span><span style="color:#E1E4E8">&#39;</span><span style="color:#B392F0">a</span><span style="color:#B392F0"> str</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> x</span><span style="color:#F97583">.</span><span style="color:#B392F0">len</span><span style="color:#E1E4E8">() &gt; y</span><span style="color:#F97583">.</span><span style="color:#B392F0">len</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#E1E4E8">        x</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">        y</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>This tells rust that both x and y have to same lifetime ‘a and that the slice returned will live at least as long as the parameters.</p>
<p>We can use references in a struct but we have to specify a lifetime</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">struct</span><span style="color:#B392F0"> ImportantExcerpt</span><span style="color:#E1E4E8">&lt;&#39;</span><span style="color:#B392F0">a</span><span style="color:#E1E4E8">&gt; {</span></span>
<span class="line"><span style="color:#E1E4E8">    part</span><span style="color:#F97583">:</span><span style="color:#F97583"> &amp;</span><span style="color:#E1E4E8">&#39;</span><span style="color:#B392F0">a</span><span style="color:#B392F0"> str</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> novel </span><span style="color:#F97583">=</span><span style="color:#B392F0"> String</span><span style="color:#F97583">::</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Call me Ishmael. Some years ago...&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> first_sentence </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> novel</span><span style="color:#F97583">.</span><span style="color:#B392F0">split</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&#39;.&#39;</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">.</span><span style="color:#B392F0">next</span><span style="color:#E1E4E8">()</span><span style="color:#F97583">.</span><span style="color:#B392F0">expect</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Could not find a &#39;.&#39;&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#B392F0"> ImportantExcerpt</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">        part</span><span style="color:#F97583">:</span><span style="color:#E1E4E8"> first_sentence,</span></span>
<span class="line"><span style="color:#E1E4E8">    };</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>This makes sure the struct can’t outlive the reference.</p>
<p>Static lifetimes are ones which live for the entire duration of the program</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> s</span><span style="color:#F97583">:</span><span style="color:#F97583"> &amp;</span><span style="color:#E1E4E8">&#39;</span><span style="color:#B392F0">static</span><span style="color:#B392F0"> str</span><span style="color:#F97583"> =</span><span style="color:#9ECBFF"> &quot;I have a static lifetime.&quot;</span><span style="color:#E1E4E8">;</span></span></code></pre>
<p>All string literals have this by default.</p>
<h2 id="testing">Testing</h2>
<p>We define tests like this:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#E1E4E8">#[cfg(test)]</span></span>
<span class="line"><span style="color:#F97583">mod</span><span style="color:#B392F0"> tests</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">    #[test]</span></span>
<span class="line"><span style="color:#F97583">    fn</span><span style="color:#B392F0"> it_works</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">        let</span><span style="color:#E1E4E8"> result </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 2</span><span style="color:#F97583"> +</span><span style="color:#79B8FF"> 2</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#B392F0">        assert_eq!</span><span style="color:#E1E4E8">(result, </span><span style="color:#79B8FF">4</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>We can run <code>cargo test</code> to run our tests:</p>
<ul>
<li><code>assert_eq!</code></li>
<li><code>assert_ne!</code></li>
<li><code>assert</code>
Tests can have custom outputs:</li>
</ul>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#E1E4E8">    #[test]</span></span>
<span class="line"><span style="color:#F97583">    fn</span><span style="color:#B392F0"> greeting_contains_name</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">        let</span><span style="color:#E1E4E8"> result </span><span style="color:#F97583">=</span><span style="color:#B392F0"> greeting</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Carol&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#B392F0">        assert!</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#E1E4E8">            result</span><span style="color:#F97583">.</span><span style="color:#B392F0">contains</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Carol&quot;</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#9ECBFF">            &quot;Greeting did not contain name, value was `{}`&quot;</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">            result</span></span>
<span class="line"><span style="color:#E1E4E8">        );</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span></code></pre>
<p>Or we can check of code panics:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#E1E4E8">#[cfg(test)]</span></span>
<span class="line"><span style="color:#F97583">mod</span><span style="color:#B392F0"> tests</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    use</span><span style="color:#79B8FF"> super</span><span style="color:#F97583">::*</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">    #[test]</span></span>
<span class="line"><span style="color:#E1E4E8">    #[should_panic]</span></span>
<span class="line"><span style="color:#F97583">    fn</span><span style="color:#B392F0"> greater_than_100</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#B392F0">        Guess</span><span style="color:#F97583">::</span><span style="color:#B392F0">new</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">200</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<h2 id="functional-programming-in-rust">Functional Programming in Rust</h2>
<p>A Closure is an anonymous function which you can save to a variable or pass it as an argument. Unlike a function closures capture values from the scope in which they are defined.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#E1E4E8">#[derive(</span><span style="color:#B392F0">Debug</span><span style="color:#E1E4E8">, </span><span style="color:#B392F0">PartialEq</span><span style="color:#E1E4E8">, </span><span style="color:#B392F0">Copy</span><span style="color:#E1E4E8">, </span><span style="color:#B392F0">Clone</span><span style="color:#E1E4E8">)]</span></span>
<span class="line"><span style="color:#F97583">enum</span><span style="color:#B392F0"> ShirtColor</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">    Red</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#B392F0">    Blue</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">struct</span><span style="color:#B392F0"> Inventory</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">    shirts</span><span style="color:#F97583">:</span><span style="color:#B392F0"> Vec</span><span style="color:#E1E4E8">&lt;</span><span style="color:#B392F0">ShirtColor</span><span style="color:#E1E4E8">&gt;,</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">impl</span><span style="color:#B392F0"> Inventory</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    fn</span><span style="color:#B392F0"> giveaway</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">&amp;</span><span style="color:#79B8FF">self</span><span style="color:#E1E4E8">, user_preference</span><span style="color:#F97583">:</span><span style="color:#B392F0"> Option</span><span style="color:#E1E4E8">&lt;</span><span style="color:#B392F0">ShirtColor</span><span style="color:#E1E4E8">&gt;) </span><span style="color:#F97583">-&gt;</span><span style="color:#B392F0"> ShirtColor</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">        user_preference</span><span style="color:#F97583">.</span><span style="color:#B392F0">unwrap_or_else</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">||</span><span style="color:#79B8FF"> self</span><span style="color:#F97583">.</span><span style="color:#B392F0">most_stocked</span><span style="color:#E1E4E8">())</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Assume that the function <code>most_stocked</code> is also defined on the implementation.
The <code>unwrap_or_else</code> method takes a closure as a parameter. The closure in this case takes no parameters and just calls the most stocked function.</p>
<p>Closures don’t require you to annotate types. This is because closures are normally in a narrow context and so the compiler can infer the types.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> expensive_closure </span><span style="color:#F97583">=</span><span style="color:#F97583"> |</span><span style="color:#E1E4E8">num</span><span style="color:#F97583">:</span><span style="color:#B392F0"> u32</span><span style="color:#F97583">|</span><span style="color:#F97583"> -&gt;</span><span style="color:#B392F0"> u32</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">        println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;calculating slowly...&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#B392F0">        thread</span><span style="color:#F97583">::</span><span style="color:#B392F0">sleep</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">Duration</span><span style="color:#F97583">::</span><span style="color:#B392F0">from_secs</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">));</span></span>
<span class="line"><span style="color:#E1E4E8">        num</span></span>
<span class="line"><span style="color:#E1E4E8">    };</span></span></code></pre>
<p>We could however if we wanted to, define the types explicitly.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583"> let</span><span style="color:#E1E4E8"> example_closure </span><span style="color:#F97583">=</span><span style="color:#F97583"> |</span><span style="color:#E1E4E8">x</span><span style="color:#F97583">|</span><span style="color:#E1E4E8"> x;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> s </span><span style="color:#F97583">=</span><span style="color:#B392F0"> example_closure</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">String</span><span style="color:#F97583">::</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;hello&quot;</span><span style="color:#E1E4E8">));</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> n </span><span style="color:#F97583">=</span><span style="color:#B392F0"> example_closure</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">5</span><span style="color:#E1E4E8">);</span></span></code></pre>
<p>After s the complier will infer that x is a string and so n will throw an error asking you to cast to a string.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> list </span><span style="color:#F97583">=</span><span style="color:#B392F0"> vec!</span><span style="color:#E1E4E8">[</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8">];</span></span>
<span class="line"><span style="color:#B392F0">    println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Before defining closure: {:?}&quot;</span><span style="color:#E1E4E8">, list);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> only_borrows </span><span style="color:#F97583">=</span><span style="color:#F97583"> ||</span><span style="color:#B392F0"> println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;From closure: {:?}&quot;</span><span style="color:#E1E4E8">, list);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">    println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Before calling closure: {:?}&quot;</span><span style="color:#E1E4E8">, list);</span></span>
<span class="line"><span style="color:#B392F0">    only_borrows</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#B392F0">    println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;After calling closure: {:?}&quot;</span><span style="color:#E1E4E8">, list);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Closures can automatically borrow data from the current scope. Because can also have multiple immutable references of list list is still accessible before and after the closure is called.</p>
<h2 id="iterators">Iterators</h2>
<p>Iterators allow us to perform a task on a sequence of items in turn.
Rust iterators are lazy they have no effect until you call the methods that consume the iterator.</p>
<p>This doesn’t do anything useful:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> v1 </span><span style="color:#F97583">=</span><span style="color:#B392F0"> vec!</span><span style="color:#E1E4E8">[</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8">];</span></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> v1_iter </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> v1</span><span style="color:#F97583">.</span><span style="color:#B392F0">iter</span><span style="color:#E1E4E8">();</span></span></code></pre>
<p>We have to use to:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> v1 </span><span style="color:#F97583">=</span><span style="color:#B392F0"> vec!</span><span style="color:#E1E4E8">[</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8">]; </span></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> v1_iter </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> v1</span><span style="color:#F97583">.</span><span style="color:#B392F0">iter</span><span style="color:#E1E4E8">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">for</span><span style="color:#E1E4E8"> val </span><span style="color:#F97583">in</span><span style="color:#E1E4E8"> v1_iter { </span></span>
<span class="line"><span style="color:#B392F0">	println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Got: {}&quot;</span><span style="color:#E1E4E8">, val);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Iterators automatically get the next value.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">pub</span><span style="color:#F97583"> trait</span><span style="color:#B392F0"> Iterator</span><span style="color:#E1E4E8"> { </span></span>
<span class="line"><span style="color:#6A737D">	// assoiated type</span></span>
<span class="line"><span style="color:#F97583">	type</span><span style="color:#B392F0"> Item</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">	</span></span>
<span class="line"><span style="color:#F97583">	fn</span><span style="color:#B392F0"> next</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">&amp;mut</span><span style="color:#79B8FF"> self</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">-&gt;</span><span style="color:#B392F0"> Option</span><span style="color:#E1E4E8">&lt;</span><span style="color:#79B8FF">Self</span><span style="color:#F97583">::</span><span style="color:#B392F0">Item</span><span style="color:#E1E4E8">&gt;; </span></span>
<span class="line"><span style="color:#E1E4E8">	</span></span>
<span class="line"><span style="color:#6A737D">	// methods with default implementations elided</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Some Methods produce iterators:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> v1</span><span style="color:#F97583">:</span><span style="color:#B392F0"> Vec</span><span style="color:#E1E4E8">&lt;</span><span style="color:#B392F0">i32</span><span style="color:#E1E4E8">&gt; </span><span style="color:#F97583">=</span><span style="color:#B392F0"> vec!</span><span style="color:#E1E4E8">[</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8">]; </span></span>
<span class="line"><span style="color:#E1E4E8">v1</span><span style="color:#F97583">.</span><span style="color:#B392F0">iter</span><span style="color:#E1E4E8">()</span><span style="color:#F97583">.</span><span style="color:#B392F0">map</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">|</span><span style="color:#E1E4E8">x</span><span style="color:#F97583">|</span><span style="color:#E1E4E8"> x </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">);</span></span></code></pre>
<p>However this breaks because the iterator isn’t consumed. So fix this we use collect to collect the data and consume the iterator:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> v1</span><span style="color:#F97583">:</span><span style="color:#B392F0"> Vec</span><span style="color:#E1E4E8">&lt;</span><span style="color:#B392F0">i32</span><span style="color:#E1E4E8">&gt; </span><span style="color:#F97583">=</span><span style="color:#B392F0"> vec!</span><span style="color:#E1E4E8">[</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8">];</span></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> v2</span><span style="color:#F97583">:</span><span style="color:#B392F0"> Vec</span><span style="color:#E1E4E8">&lt;_&gt; </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> v1</span><span style="color:#F97583">.</span><span style="color:#B392F0">iter</span><span style="color:#E1E4E8">()</span><span style="color:#F97583">.</span><span style="color:#B392F0">map</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">|</span><span style="color:#E1E4E8">x</span><span style="color:#F97583">|</span><span style="color:#E1E4E8"> x </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">.</span><span style="color:#B392F0">collect</span><span style="color:#E1E4E8">();</span></span></code></pre>
<h2 id="extra-patterns">Extra Patterns</h2>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> x </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">; </span></span>
<span class="line"><span style="color:#6A737D">// OR </span></span>
<span class="line"><span style="color:#F97583">match</span><span style="color:#E1E4E8"> x {</span></span>
<span class="line"><span style="color:#79B8FF">	1</span><span style="color:#F97583"> |</span><span style="color:#79B8FF"> 2</span><span style="color:#F97583"> =&gt;</span><span style="color:#B392F0"> println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;one or two&quot;</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#79B8FF">	3</span><span style="color:#F97583"> =&gt;</span><span style="color:#B392F0"> println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;three&quot;</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#E1E4E8">	_ </span><span style="color:#F97583">=&gt;</span><span style="color:#B392F0"> println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;anything&quot;</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Inclusive range:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> x </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 5</span><span style="color:#E1E4E8">; </span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">match</span><span style="color:#E1E4E8"> x { </span></span>
<span class="line"><span style="color:#79B8FF">	1</span><span style="color:#F97583">..=</span><span style="color:#79B8FF">5</span><span style="color:#F97583"> =&gt;</span><span style="color:#B392F0"> println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;one through five&quot;</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#E1E4E8">	_ </span><span style="color:#F97583">=&gt;</span><span style="color:#B392F0"> println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;something else&quot;</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Since chars are often casted to integers we can:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> x </span><span style="color:#F97583">=</span><span style="color:#9ECBFF"> &#39;c&#39;</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">match</span><span style="color:#E1E4E8"> x { </span></span>
<span class="line"><span style="color:#9ECBFF">	&#39;a&#39;</span><span style="color:#F97583">..=</span><span style="color:#9ECBFF">&#39;j&#39;</span><span style="color:#F97583"> =&gt;</span><span style="color:#B392F0"> println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;early ASCII letter&quot;</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#9ECBFF">	&#39;k&#39;</span><span style="color:#F97583">..=</span><span style="color:#9ECBFF">&#39;z&#39;</span><span style="color:#F97583"> =&gt;</span><span style="color:#B392F0"> println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;late ASCII letter&quot;</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#E1E4E8">	_ </span><span style="color:#F97583">=&gt;</span><span style="color:#B392F0"> println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;something else&quot;</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<h2 id="destructuring">Destructuring</h2>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">struct</span><span style="color:#B392F0"> Point</span><span style="color:#E1E4E8"> { </span></span>
<span class="line"><span style="color:#E1E4E8">	x</span><span style="color:#F97583">:</span><span style="color:#B392F0"> i32</span><span style="color:#E1E4E8">, </span></span>
<span class="line"><span style="color:#E1E4E8">	y</span><span style="color:#F97583">:</span><span style="color:#B392F0"> i32</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">	let</span><span style="color:#E1E4E8"> p </span><span style="color:#F97583">=</span><span style="color:#B392F0"> Point</span><span style="color:#E1E4E8"> { x</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">, y</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> 7</span><span style="color:#E1E4E8"> };</span></span>
<span class="line"><span style="color:#F97583">	let</span><span style="color:#B392F0"> Point</span><span style="color:#E1E4E8"> { x</span><span style="color:#F97583">:</span><span style="color:#E1E4E8"> a, y</span><span style="color:#F97583">:</span><span style="color:#E1E4E8"> b } </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> p; </span></span>
<span class="line"><span style="color:#B392F0">	assert_eq!</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">, a); </span><span style="color:#B392F0">assert_eq!</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">7</span><span style="color:#E1E4E8">, b);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>You don’t have to name the destructured elements:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#F97583">fn</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() { </span></span>
<span class="line"><span style="color:#F97583">	let</span><span style="color:#E1E4E8"> p </span><span style="color:#F97583">=</span><span style="color:#B392F0"> Point</span><span style="color:#E1E4E8"> { x</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">, y</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> 7</span><span style="color:#E1E4E8"> };</span></span>
<span class="line"><span style="color:#F97583">	let</span><span style="color:#B392F0"> Point</span><span style="color:#E1E4E8"> { x, y } </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> p; </span></span>
<span class="line"><span style="color:#B392F0">	assert_eq!</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">, x); </span></span>
<span class="line"><span style="color:#B392F0">	assert_eq!</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">7</span><span style="color:#E1E4E8">, y); </span></span>
<span class="line"><span style="color:#E1E4E8">	</span></span>
<span class="line"><span style="color:#F97583">	match</span><span style="color:#E1E4E8"> p { </span></span>
<span class="line"><span style="color:#B392F0">		Point</span><span style="color:#E1E4E8"> { x, y</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8"> } </span><span style="color:#F97583">=&gt;</span><span style="color:#B392F0"> println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;On the x axis at {x}&quot;</span><span style="color:#E1E4E8">), </span></span>
<span class="line"><span style="color:#B392F0">		Point</span><span style="color:#E1E4E8"> { x</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">, y } </span><span style="color:#F97583">=&gt;</span><span style="color:#B392F0"> println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;On the y axis at {y}&quot;</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#B392F0">		Point</span><span style="color:#E1E4E8"> { x, y } </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> { </span><span style="color:#B392F0">println!</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;On neither axis: ({x}, {y})&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">	}</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre> </div> <footer data-astro-cid-k2f5zb5c> <p data-astro-cid-k2f5zb5c>2025 &copy;  Richard</p> </footer>  </html>